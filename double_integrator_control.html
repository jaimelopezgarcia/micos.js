<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Integration Test</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>
</head>


<style>
    /*
    * lets make a grid of 2 columns main_canvas/plots_panel, and plots_panel will have all its child divs in a row with a scrollbar for 
    * overflow
    */

    #controls_panel{
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
        width: 400px;
        height: 800px;
        margin: 0px;
    }

    body{
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
    }


    .main_canvas{
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
        width: 1800px;
        height: 800px;
        margin: 0px;
        overflow-y: auto ;
        overflow-x: auto;
    }

    .svg_container{
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
        width: 800px;
        height: 800px;
        margin: 0px;
    }

    .svg{
        border: 1px solid black;
        width: 800px;
        height: 800px;
        margin: 0px;
    }

    #timeSlider{
        width: 800px;
    }

    



</style>
<body>

    <div id = "controls">
        <div id = "controls_panel">


            </div>

    </div>
    <div id = "main_canvas" class = "main_canvas">
        </div>


    <script type="module">
            import {Drawer} from "./drawing.js"; //drawer.drawState(STATE,VISUAL_OPTIONS,particles_group_id); is the function to draw the state of the system
            import {displayObjectInDiv, displayMouseCoords} from "./utils.js";
            import {initState,StateUtils, stepSemiEulerActiveSet, integrateSystem} from "./solver.js";   
            import {SelectionPanel} from "./dashboardUI.js";
            /*Example usage of SelectionPanel
                const data = {
                    Particle_0: ['X Position', 'Y Position'],
                    Particle_1: ['X Position', 'Y Position']
                };

                const selectionPanel = new SelectionPanel(data);

                //methods
                selectionPanel.gatherSelections(); //returns an array of the selected checkboxes, for instance ['Particle_0->X Position', 'Particle_1->Y Position']
                selectionPanel.clearSelections(); //clears all the selected checkboxes
                selectionPanel.selectAll(); //selects all the checkboxes
                */

                /* integrateSystem, usage
                //default parameters
                {
                    "alpha": 0.1,
                    "beta": 0.1,
                    "dt": 0.01,
                    "muFriction": 0.0,
                    "collisionThreshold": 0.01,
                }
                let actuator = new ForceActuator([0],[0,0.1]);
                let forceActuator = actuator.getForceArray.bind(actuator);
                integrateSystem(STATE,nsteps,
                --callbacksActuators =-- [forceActuator],
                 --method =-- "SemiEulerActiveSet", --PARAMETERS =-- {})
                */

                /*
                Example usage drawer


                let drawer = new Drawer(svgMain, [-2,2],[-2,2]);

            
                let nsteps = stateStoryModel.length;

                drawer.drawState(stateStoryModel[0]);

                                function canvas2ModelCallback(points){
                    return drawer.canvas2Model(points, true)// true for shifing origin, false if transforming forces
                }

                */

        

        function doubleIntegratorConfig(x0, v0, mass, dampingCoef = 0.){
            let initialState = {
                xs: [x0],
                vs: [v0],
                masses: [mass],
                constraints_distance: [],
                constraints_pin: [],
                collisions: [],
                gravity: [0,[0,-1]],
                time: 0,
                polygons: [],
                damping: [ [[0],dampingCoef] ],
            }

            return initialState;
        }
 

        class ForceActuator{
            //just a external force that can be applied to selected particles
            constructor(particle_ids, force){
                this.particle_ids = particle_ids;
                this.force = force;//[2] array
                
            }
            getName(){
                return "ForceActuator";
            }
            getForceArray(STATE){

                // forceArray must be a [nparticles,2] array
                //so we initialize it with zeros
                let forceArray = math.zeros([STATE.xs.length,2]);

                for(let i = 0; i < this.particle_ids.length; i++){
                    let particle_id = this.particle_ids[i];
                    forceArray[particle_id] = this.force;
                    
                    

                }
                console.log
                return forceArray
                

            }
        }

        // lets make a pid controller for the double integrator to reach a target position on the y axis

        class PIDController{
            constructor(Kp,Ki,Kd,setPoint,dt){
                this.Kp = Kp;
                this.Ki = Ki;
                this.Kd = Kd;
                this.integral = 0;
                this.prev_error = 0;
                this.setPoint = setPoint;
                this.dt = dt;
                this.init = true;
            }

            reset(){
                this.integral = 0;
                this.prev_error = 0;
                this.init = true;
            }

            getName(){
                return "PIDController";
            }

            getForceArray(STATE){
                //lets calculate the error and force and we'll use a force actuator to apply the force
                let error = this.setPoint - STATE.xs[0][1];
                this.integral += error*this.dt;
                //let derivative = (error - this.prev_error)/this.dt;
                let derivative = 0;
                if (this.init){
                    this.init = false;
                    
                }else{
                    derivative = (error - this.prev_error)/this.dt;
                }
                let force = this.Kp*error + this.Ki*this.integral + this.Kd*derivative;
                this.prev_error = error;
                
                let forceActuator = new ForceActuator([0],[0,force]);
                return forceActuator.getForceArray(STATE);
 
            }

            getForce(STATE){
                //lets calculate the error and force and we'll use a force actuator to apply the force
                let forceArray = this.getForceArray(STATE);
                let force = forceArray[0];
                return force;
 
            }

            getControlledVarPositionVelocity(STATE){
                // in this case we return [y,vy]
                return [STATE.xs[0][1],STATE.vs[0][1]];
            }

            getTimeArrayControlSignalControlledVar(stateStory){
                // we return a [nsteps,3] array with u,y,vy and a [nsteps] array with time
                
                this.reset();

                let timeArray = stateStory.map((state) => state.time);

                let uArray = [];
                let yArray = [];
                let vyArray = [];

                for(let i = 0; i < stateStory.length; i++){
                    let state = stateStory[i];
                    let u = this.getForce(state)[1];
                    let [y,vy] = this.getControlledVarPositionVelocity(state);
                    uArray.push(u);
                    yArray.push(y);
                    vyArray.push(vy);
                }

                return [timeArray,uArray,yArray,vyArray];

            }

            
            getControllerInstantaneousPower(STATE){
                //lets calculate the power consumed by the controller
                //P_{consumed} = |u*\dot{controlled_variable}| = |f_{ycontroller}*\dot{y}| 
                let force = this.getForce(STATE);
                let vy = STATE.vs[0][1];
                let power = force[1]*vy//lets keep the sign
                // of the power just for debugging purposes, so we can now when it is adding or removing energy
                return power;
            }
            getControllerTotalEnergyConsumed(stateStory){
                /*
                This function returns two arrays of [nsteps] elements, one with the cumulative energy consumed by the controller
                and the other with the power consumed by the controller at each step
                */
                //lets calculate the total energy consumed by the controller
                //E_{consumed} = \int_{0}^{t} |u*\dot{controlled_variable}|dt
                let totalEnergy = 0;
                let arrayCumEnergy = [];
                let powerArray = [];
                let power = 0;
                arrayCumEnergy.push(0);
                powerArray.push(0);

                //lets get the dt from the stateStory at each step
                for (let i = 0; i < stateStory.length-1; i++){
                    let dt = stateStory[i+1].time - stateStory[i].time;
                    let power = this.getControllerInstantaneousPower(stateStory[i]);
                    totalEnergy += math.abs(power)*dt;
                    arrayCumEnergy.push(totalEnergy);
                    powerArray.push(power);
                }
                return [arrayCumEnergy,powerArray];
            }

            getSetpoint(){
                return this.setPoint;
            }

            getErrorTime(stateStory){
                //returns an array with the error at each time step
                let errorArray = [];
                let timeArray = stateStory.map((state) => state.time);
                for(let i = 0; i < stateStory.length; i++){
                    let error = this.setPoint - stateStory[i].xs[0][1];
                    errorArray.push(error);
                    timeArray.push(stateStory[i].time);

                }
                return [timeArray,errorArray];
            }


        }


        function plotResults(stateStory,controller,parentDivId){
            //lets go over some basic diff equations/classical mechanics concepts so things are clear.
            // ok so m\dot\dot{x} = f = u. Multiplying \dot{x} to both sides we get m\dot{x}\dot\dot{x} = u\dot{x}
            //we can use the relationship \dot{x}\dot\dot{x} = \frac{1}{2}\frac{d}{dt}(\dot{x}^2)
            // so we get 1/2*md(x**2)/dt = u\dot{x}dt, the extension to multiple particles and control signals is straightforward
            // now for generalized coordinates q, we'll still have a quadratic relationship but with different mass matrix
            // for torque we get I\dot{\omega} = \tau = u_{tau}, so basically the same but with angular velocity and torque
            // d1/2I\omega^2/dt = u_{tau}\omega dt So, generalized forces go in pairs with generalized velocities/displacements
            // for both cartesian and generalized coordinates, the application is straightforward
            //lets calculate the different magnitudes we'll be plotting


            //state already has totalEnergy variable , lets get cumulative energy and power consumed by the controller

            let totalEnergyArray = stateStory.map((state) => state.totalEnergy);
            let [cumEnergyArray,powerArray] = controller.getControllerTotalEnergyConsumed(stateStory);
            let [timeArray,uArray,yArray,vyArray] = controller.getTimeArrayControlSignalControlledVar(stateStory);

            //lets do two plots one with cumEnergy powerArray totalEnergy vs time 
            //and the other with uArray yArray vyArray vs time

            let traces = [
                {
                    x: timeArray,
                    y: uArray,
                    mode: 'lines',
                    name: 'Control Signal',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: yArray,
                    mode: 'lines',
                    name: 'Controlled Variable Position',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: vyArray,
                    mode: 'lines',
                    name: 'Controlled Variable Velocity',
                    type: 'scatter'
                },
                //lets add twoa additional traces, one dashed horizontal line for the setpoint and a trace with the error in red

                {
                    x: timeArray,
                    y: Array(timeArray.length).fill(controller.getSetpoint()),
                    mode: 'lines',
                    name: 'Setpoint',
                    type: 'scatter',
                    line: {
                        dash: 'dashdot',
                        color: 'black'
                    }
                },
                {
                    x: controller.getErrorTime(stateStory)[0],
                    y: controller.getErrorTime(stateStory)[1],
                    mode: 'lines',
                    name: 'Error',
                    type: 'scatter',
                    line: {
                        color: 'red'
                    }
                }
            ];




            let layout = {
                title: 'Control Signal and Controlled Variable vs Time',
                xaxis: {
                    title: 'Time'
                },
                yaxis: {
                    title: 'Control Signal/Controlled Variable'
                }
            };


            let traces2 = [
                {
                    x: timeArray,
                    y: cumEnergyArray,
                    mode: 'lines',
                    name: 'Controller Cumulative Energy Consumed',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: powerArray,
                    mode: 'lines',
                    name: 'Controller Power',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: totalEnergyArray,
                    mode: 'lines',
                    name: 'System Total Energy',
                    type: 'scatter'
                }
            ];

            let layout2 = {
                title: 'Energy and Power vs Time',
                xaxis: {
                    title: 'Time'
                },
                yaxis: {
                    title: 'Energy/Power'
                }
            };

            let plotDiv1 = document.createElement("div");
            let plotDiv2 = document.createElement("div");
            plotDiv1.setAttribute("id","plotDiv1");
            plotDiv2.setAttribute("id","plotDiv2");
            document.getElementById(parentDivId).appendChild(plotDiv1);
            document.getElementById(parentDivId).appendChild(plotDiv2);



            Plotly.newPlot(plotDiv1, traces, layout);
            Plotly.newPlot(plotDiv2, traces2, layout2);





        }

     

        function main(Kp,Ki,Kd,setPoint,dt,T,y0in = 0,vy0in = 0){
            console.log("Kp,Ki,Kd,setPoint,dt,T,y0in,vy0in",Kp,Ki,Kd,setPoint,dt,T,y0in,vy0in);
            // if any of the parameters is not passed, throw error
            if (Kp == undefined || Ki == undefined || Kd == undefined || setPoint == undefined || dt == undefined || T == undefined){
                throw new Error("Missing parameters");
            }

            //lets test the double integrator with a force actuator
            //we integrate the system with a actuator callaback 
            //then we draw the state of the system and create a slider to select the time snapshot of the stateStory array that
            //integrateSystem returns

            //state config parameters
            let [x0,v0,mass,dampingCoef] = [[0,y0in],[0,vy0in],1,0];
            let initialState = doubleIntegratorConfig(x0,v0,mass,dampingCoef);

            //actuator config parameters, constant force of 0.1 in the y direction
          //  let actuator = new ForceActuator([0],[0,0.1]);
            //let forceActuator = actuator.getForceArray.bind(actuator);

            //lets create a PID controller to reach a target position on the y axis

            let nsteps = Math.floor(T/dt);

            let pidController = new PIDController(Kp,Ki,Kd,setPoint,dt);
            let forceActuator = pidController.getForceArray.bind(pidController);
            window.pidController = pidController;
            //default parameters
            
            let stateStoryModel = integrateSystem(initialState,nsteps,[forceActuator],"SemiEulerActiveSet",{"dt":dt});
            window.stateStoryModel = stateStoryModel;
            window.initState = stateStoryModel[0];
            //lets create a svg if it not exists to draw the state of the system
            //lets use vanilla svg and js, no d3 or plotly for this one

            
            let mainCanvas = document.getElementById("main_canvas");
            let parentDiv = document.getElementById("svg_container");
            if(parentDiv == null){
                parentDiv = document.createElement("div");
                parentDiv.setAttribute("id","svg_container");
                //lets set a classname to make in the css the slider to be in the bottom of the svg
                parentDiv.setAttribute("class","svg_container");
                mainCanvas.appendChild(parentDiv);
            }

            let svgDraw = document.getElementById("svgDraw");
            if(svgDraw == null){
                svgDraw = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svgDraw.setAttribute("id","svgDraw");
                svgDraw.setAttribute("class","svg");
                parentDiv.appendChild(svgDraw);
            }

            let [xModelDomain,yModelDomain] = [[-1,1],[-1,1]];
            let drawer = new Drawer(svgDraw);

            //draw the last state of the stateStory array
            drawer.drawState(stateStoryModel[nsteps-1]);

            //create a slider to select the time snapshot of the stateStory array
            let slider = document.getElementById("timeSlider");
            if(slider == null){
                slider = document.createElement("input");
                slider.setAttribute("type","range");
                slider.setAttribute("min","0");
                slider.setAttribute("max",nsteps-1);
                slider.setAttribute("value",nsteps-1);
                slider.setAttribute("id","timeSlider");
                parentDiv.appendChild(slider);
            }


            //lets create another div to print the state
            let stateDiv = document.createElement("div");
            stateDiv.setAttribute("id","stateDiv");
            //lets append child to the mainCanvas
            let body = document.getElementsByTagName("body")[0];
            body.appendChild(stateDiv);
            

            //add event listener to the slider
            slider.addEventListener("input", function(){
                let time = parseInt(slider.value);
                drawer.drawState(stateStoryModel[time]);
                displayObjectInDiv(stateStoryModel[time],"stateDiv");
            })

            function canvas2ModelCallback(points){
                    return drawer.canvas2Model(points, true)// true for shifing origin, false if transforming forces
                }

                displayMouseCoords( svgDraw, canvas2ModelCallback);

            //lets plot the results of the controller
            let plotsDivId = "plotsDiv";
            let plotsDiv = document.getElementById(plotsDivId);
            if(plotsDiv == null){
                plotsDiv = document.createElement("div");
                plotsDiv.setAttribute("id",plotsDivId);
                mainCanvas.appendChild(plotsDiv);
            }
            else{
                //clear the div
                plotsDiv.innerHTML = "";
            }

            plotResults(stateStoryModel,pidController,plotsDivId);

            //lets draw an horizontal line with the setpoint on the main svg

            let ySetpoint = pidController.getSetpoint();
            let setPointHlineModel = [[-1,ySetpoint],[1,ySetpoint]];
            //lets remove the previous setPointHline if it exists
            let setPointHline = document.getElementById("setPointHline");
            if(setPointHline != null){
                setPointHline.remove();
            }
            let setPointHlineCanvas = drawer.model2Canvas(setPointHlineModel,true);
            let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1",setPointHlineCanvas[0][0]);
            line.setAttribute("y1",setPointHlineCanvas[0][1]);
            line.setAttribute("x2",setPointHlineCanvas[1][0]);
            line.setAttribute("y2",setPointHlineCanvas[1][1]);
            line.setAttribute("stroke","black");
            line.setAttribute("stroke-width","2");
            line.setAttribute("stroke-dasharray","5,5");
            line.setAttribute("id","setPointHline");
            svgDraw.appendChild(line);



        }

      
    function addControls(){
        let controlsPanel = document.getElementById("controls_panel");
        let controls = [
            {
                "label": "Kp",
                "id": "Kp",
                "type": "range",
                "value": 0.5,
                "step": 0.05,
                "min": 0,
                "max": 20
            },
            {
                "label": "Ki",
                "id": "Ki",
                "type": "range",
                "value": 0,
                "step": 0.05,
                "min": 0,
                "max": 20
            },
            {
                "label": "Kd",
                "id": "Kd",
                "type": "range",
                "value": 0.5,
                "step": 0.05,
                "min": 0,
                "max": 20
            },
            {
                "label": "setPoint",
                "id": "setPoint",
                "type": "range",
                "value": 0.5,
                "step": 0.05,
                "min": -10,
                "max": 10
            },
            {
                "label": "dt",
                "id": "dt",
                "type": "range",
                "value": 0.1,
                "step": 0.01,
                "min": 0.01,
                "max": 1
            },
            {
                "label": "T",
                "id": "T",
                "type": "range",
                "value": 20,
                "step": 1,
                "min": 1,
                "max": 100
            },
            {
                "label": "y0in",
                "id": "y0in",
                "type": "range",
                "value": 0,
                "step": 0.1,
                "min": -10,
                "max": 10
            },
            {
                "label": "vy0in",
                "id": "vy0in",
                "type": "range",
                "value": 0,
                "step": 0.1,
                "min": -10,
                "max": 10
            }
        ];



        for (let i = 0; i < controls.length; i++){
            let control = controls[i];
            let label = document.createElement("label");
            label.setAttribute("for",control.id);
            label.innerHTML = `${control.label}: ${control.value}`;
            let input = document.createElement("input");
            input.setAttribute("type",control.type);
            input.setAttribute("id",control.id);
            input.setAttribute("value",control.value);
            input.setAttribute("step",control.step);
            input.setAttribute("min",control.min);
            input.setAttribute("max",control.max);
            controlsPanel.appendChild(label);
            controlsPanel.appendChild(input);
        }


        return controls;

    }
          

    

    function updateCallback(){
        let Kp = parseFloat(document.getElementById("Kp").value);
        let Ki = parseFloat(document.getElementById("Ki").value);
        let Kd = parseFloat(document.getElementById("Kd").value);
        let setPoint = parseFloat(document.getElementById("setPoint").value);
        let dt = parseFloat(document.getElementById("dt").value);
        let T = parseFloat(document.getElementById("T").value);
        let y0in = parseFloat(document.getElementById("y0in").value);
        let vy0in = parseFloat(document.getElementById("vy0in").value);
        //lets update the label of the controls
        let controls = ["Kp","Ki","Kd","setPoint","dt","T","y0in","vy0in"];
        controls.forEach((control) => {
            document.querySelector(`label[for=${control}]`).innerHTML = `${control}: ${document.getElementById(control).value}`;
        });


        

        main(Kp,Ki,Kd,setPoint,dt,T,y0in,vy0in);
    }

    let controls = addControls();
    //any change on the controls will trigger the updateCallback


    controls.forEach((control) => {
        document.getElementById(control.id).addEventListener("change",updateCallback);
    });

    //initial call to main
    updateCallback();
    </script>
</body>
</html>