<!DOCTYPE html>
<html>
  <style>
      #debug-info {
      position: absolute;

      border: 1px solid black;
      padding: 10px;
      background-color: white;
      max-height: 500px;
      overflow-y: auto;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      border: 1px solid black;
      padding: 10px;
      background-color: white;
    }

    #svgMain {
      border: 1px solid black;
    }
  </style>
  <head>
    <title>Constraint Solver Tests</title>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.2/math.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>


    <div id = "controls">
        <button id = "stepButton">Step</button>
    </div>

    <svg id="svgMain" width="800" height="800">
     </svg>

        <div id="debug-info"></div>   


    <script type="module">
        import {getNeighborsDelauney} from './math_utils.js';
        import {computeJacobians,
              stepUnpackStateWithContact, Polygon,
               CollisionHandler, solveConstraints, computeExternalForces,
               calculateConstraintForces , stepSemiEulerContact} from "./solver.js";
        import {drawCircles, drawLines, drawArrow,
             drawPolygon, drawParticles,PolygonDrawer, CollisionDrawer,Drawer} from "./drawing.js";
        import {model2Canvas, canvas2Model,translate, scale} from "./math_utils.js";
        import {makeParticleDraggable} from "./dashboardUI.js";
        import {displayMouseCoords,displayObjectInDiv} from "./utils.js";
        //computeJacobians(constraints,xarray,varray)-> return [J, dot_J]; [sconstraints, 2*nparticles] matrices
        // position array is flattened [x1,y1,x2,y2,...]
        //STATE object has everything needed to run the simulation plus additional information for debugging
        //mandatory fields of STATE are    ["constraints_distance", "constraints_pin","collisions","polygons", "xs", "vs", "masses"]
        // collisions is an array of type [[iP,jE,Polidx],...] where iP is the particle index, jE is the edge index, Polidx is the polygon index
        //the constraint objects array will have the order [distance, pin, contact]
        //drawCircles(svg,xs, radii = 5, color = "red", groupCirclesId = "circlesGroup", display_indices = true) -> draws circles in svg
        //drawLines(svg, xsOrigs, xsDests, color = "black", groupLinesId = "linesGroup") -> draws lines in svg
        //drawPolygon(SVG,polygonId, points, color = "black") -> draws a polygon in svg
        //drawArrow(svg,porigin,pend, id = "arrow", class_name = "arrow",color = "black", width = 2) -> draws an arrow in svg
                /*
    model2Canvas(pointsModel, originModel, canvasX, canvasY, modelX, modelY)
    pointsModel is a [npoints, 2] array
    originModel is a [2] array, usually [0, 0] but we might want to reference shifted axis in the model space
    returns a [npoints, 2] array of points transformed from model to canvas coordinates
    canvasX, canvasY are the dimensions of the canvas (usually the canvas.width and canvas.height)
    modelX, modelY are the dimensions of the model space (usually [-1,1]x[-1,1])

        canvas2Model(pointsCanvas, originModel, canvasX, canvasY, modelX, modelY)
            pointsCanvas is a [npoints, 2] array
            originModel is a [2] array, usually [0, 0] but we might want to reference shifted axis in the model space
            returns a [npoints, 2] array of points transformed from canvas to model coordinates
            canvasX, canvasY are the dimensions of the canvas (usually the canvas.width and canvas.height)
            modelX, modelY are the dimensions of the model space (usually [-1,1]x[-1,1])
        
        */

            /* Basic usage of the Polygon class
    * let vertices = [[0,0],[1,0],[1,1],[0,1]];
    * let polygon = new Polygon(vertices, 0);
    * let point = [0.5,0.5];
    * let [closest_edge,distance] = polygon.getClosestEdge(point);
    * let closest_point = polygon.getClosestPoint2Edge(point,polygon.edges[closest_edge]);
    * let normal = polygon.getNormal(closest_edge);
    * let normal_projection = polygon.getClosestEdgeNormalProjection(point);
    * let normal_projection_vector = polygon.getClosestEdgeNormalProjectionVector(point);
    * let distance2edge = polygon.getDistance2Edge(point,polygon.edges[closest_edge]);
    * let center = polygon.getCenter();
    * let edge_midpoint = polygon.getEdgeMidpoint(closest_edge);
    * let normals = polygon.getNormals();
    * let closest_edge_normal_projection = polygon.getClosestEdgeNormalProjection(point);
    */
   // makeParticleDraggable(SVG,particle_id, particle_idx,
  // STATE,updateState,canvas2Model,
             //                   ){
    // Collision handler has method updateCollisionsMap(collisions, xs, polygons, threshold)
    // collisions is an array of type [[iP,jE,polygonObj],...]-->[collisions,new_collisions,resolved_collisions]
    // collisions is the updated array of collisions, new and resolver are returned for debugging and visualization
        const SVG = document.getElementById("svgMain");
        function updateState(property,value,STATE){
            STATE[property] = value;
                }        

        
            
        function generateDummyState(){
            // two particles with a distance constraint
            // a polygon  on the right side
            // xs particles positions [nparticles,2] array
            // vs particles velocities [nparticles,2] array (lets set it to zero)
            // masses particles masses [nparticles] array (1,1)
            // constraints_distance distance constraints [[i,j,distance],...] array
            // constraints_pin pin constraints [[i,point,distance],...] array, empty in this case
            //collisions is an array of type [[iP,jE,Polidx],...] 
            //where iP is the particle index, jE is the edge index, Polidx is the polygon index, empty at first
            //polygons is an array of polygon vertices [[p1,p2,...],...] array
            // lets create a square polygon
            // Lets work in the [-1,1]x[-1,1] model space, we will transform to canvas space later

        
            //polygonc created clockwise
            let STATE = {
                //"xs": [[-0.2,0.2],[-0.2+0.5,0.2+0.5]],
                //3 particles
                "xs": [[-0.2,0.2],[-0.2+0.5,0.2+0.5],[-0.2+0.5,0.2]],
                "vs": [[0,0],[0,0],[0,0]],
                "masses": [1,1,1],
                "constraints_vals": [],
                "constraints_jacobians": [],//this must be of the form [ [particlesIndices, jacobian],...]
                "constraints_dot_jacobians": [],//this must be of the form [ [particlesIndices, jacobian],...]
                "constraints_distance": [[0,1,0.5]],
                "constraints_pin": [],
                "collisions": [],
                "new_collisions": [],//this is for debugging
                "resolved_collisions": [],//this is for debugging
                "polygons": [[[0,0],[0.5,0],[0.5,-0.5],[0,-0.5] ]],
                "J": null,
                "dotJ": null,
                "t":0,
                "gravity": [0.1,[0,-1]],
                "springs": [[1,2,1,0.5]],//particle1, particle2, stiffness, restLength

            };
            //lets shift polygon points to the right with translate
            STATE.polygons = STATE.polygons.map((polygon) => {
                return scale(translate(polygon,[0.0,0]),2,1);
            });
            console.log(STATE);
            
            return STATE;
        }


        function rigidRectangleState(width, height,origin=[0,0]){
        //we'll create the rectangle 4 points, and we'll use use getNeighborsDelauney to 
        // set the distance constraints
        let xs = [[origin[0],origin[1]],
                  [origin[0]+width,origin[1]],
                  [origin[0]+width,origin[1]+height],
                  [origin[0],origin[1]+height]];

        let neighs = getNeighborsDelauney(xs);
        //neighs is a dict of particle_idx: [neighbors_idxs]
        // we have to iterate over the keys of neighs get the distances and create the constraints
        // to avoid duplicates we store the (idxa,idxb) visited pairs, ordered idxa < idxb
        // so for every new pair we sort it and check if it is in the set of visited pairs
        // if it is not we add it to the set and create the constraint
        // we sort the pairs and turn into a string to add to the set example [1,2] => "1,2" [2,1] => "1,2"
        let visitedPairs = new Set();
        let constraints_distance = [];
        for (let particle_idx in neighs){
            let neighbors = neighs[particle_idx];
            for (let i = 0; i < neighbors.length; i++){
                let particle_idx2 = neighbors[i];
                let pair = [particle_idx, particle_idx2];
                pair.sort();
                let pairStr = pair.join(",");
                if (!visitedPairs.has(pairStr)){
                    visitedPairs.add(pairStr);
                    //particle_idx and particle_idx2 to Integer
                    particle_idx = parseInt(particle_idx);
                    particle_idx2 = parseInt(particle_idx2);
                    let distance = math.distance(xs[particle_idx], xs[particle_idx2]);
                    constraints_distance.push([particle_idx, particle_idx2, distance]);
                }
            }
        }

      
        let STATE = {
            neighbors: neighs,
            xs: xs,
            constraints_distance: constraints_distance,
            constraints_pin: [],
            "constraints_values": [],
            "constraints_mae": 0,
            "targets": [],
            "masses": [1,1,1,1],
            "vs": [[0,0],[0,0],[0,0],[0,0]],
            "collisions": [],
            "polygons": [],
            "J": null,
            "dotJ": null,
            "t":0,
            "gravity": [0.1,[0,-1]],
            "polygons": [[[0,0],[0.5,0],[0.5,-0.5],[0,-0.5] ]],





        };

        STATE.polygons = STATE.polygons.map((polygon) => {
                return scale(translate(polygon,[0.0,0]),2,1);
            });

        return STATE;
      
    }

        function getJacobiansConstraints(STATE){
            let [constraintsObjs, _1, _2] = stepUnpackStateWithContact(STATE);
            //All the constraints have the following methods
            //getConstraintValue(xs) -> returns the value of the constraint
            //getParticleIndices() -> returns the indices of the particles involved in the constraint
            //getJacobianParticles(xarray) -> returns the jacobian of the constraint with respect to the particles, a [nparticles_involved,2] array
            //getDotJacobianParticles(varray) -> returns the time derivative of the jacobian of the constraint with respect to the particles, a [nparticles_involved,2] array
            let [constraintsVals, constraintsJacobians, constraintsDotJacobians] = [[],[],[]];
            constraintsObjs.map((constraint) => {
                let particlesIndices = constraint.getParticleIndices();
                constraintsVals.push(constraint.getConstraintValue(STATE.xs));
                constraintsJacobians.push([particlesIndices, constraint.getJacobianParticles(STATE.xs)]);
                constraintsDotJacobians.push([particlesIndices, constraint.getDotJacobianParticles(STATE.vs)]);
            });

            return [constraintsVals, constraintsJacobians, constraintsDotJacobians];
        }

   
        
       // let STATE = generateDummyState();
        let STATE = rigidRectangleState(0.2,0.2,[0.6,0.2]);
        let colHandler = new CollisionHandler();
        let drawer = new Drawer(SVG);
        drawer.drawState(STATE);

        let particles = SVG.querySelectorAll(".particle");
        let [canvasX, canvasY] = [SVG.width.baseVal.value, SVG.height.baseVal.value];
        let [modelX, modelY] = [2,2];
        let canvas2ModelCallback = (pointCanvas) => {
            return drawer.canvas2Model(pointCanvas,true);

        }

        let displayStateCallback = () => {
            displayObjectInDiv(STATE, "debug-info");
        }

        let PARAMETERS = {
            "dt": 0.05,
            "alpha":6,
            "beta":6,
            "collisionThreshold": 0.05,
            "muFriction": 0.05,
        }


        let mainCallback = () => {
           
           
            let newSTATE = stepSemiEulerContact(STATE,PARAMETERS);
            for (let key in newSTATE){
                updateState(key,newSTATE[key],STATE);
            }
            displayObjectInDiv(STATE, "debug-info");

            //lets draw the state
            drawer.drawState(STATE);


        }

        let callbacksParticles = [displayStateCallback, mainCallback];
        particles.forEach((particle,idx) => {
            makeParticleDraggable(SVG,particle.id, idx, STATE, updateState,
                                 canvas2ModelCallback,  [displayStateCallback, mainCallback]);
        });
        window.STATE = STATE;
        displayMouseCoords(SVG, canvas2ModelCallback)

        let stepButton = document.getElementById("stepButton");
        stepButton.addEventListener("click", mainCallback);
       


        </script>
    </body>
</html>
