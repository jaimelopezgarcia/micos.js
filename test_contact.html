<!DOCTYPE html>
<html>
<head>
    <title>Constraint solver contact resolution testing</title>
    <style>
        svg {
            border: 1px solid black;
        }

        polygon {
            fill: blue;
            stroke: black;
        }
        .debug_solve_constraints {
            border: 1px solid black;
            padding: 10px;
            margin: 10px;
            overflow:auto;
            height: 300;
        }
        
    </style>
</head>
<body>
        
    </div>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.2/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.11/dist/interact.min.js"></script>

    <!-- lets create a button to trigger the Maincallback, we'll add the logic later, now just the button and the text -->
    <button id="button_main">MainCallback</button>

    <svg width="600" height="600" id="main">
        <!-- Add your SVG elements here -->
    </svg>
    <div id = "state">
    </div>
    <div id = "info_particles">
    </div>
    <div id = "debug_collisions"></div>
    <div id = "debug_solve_constraints" class = "debug_solve_constraints">


    <script type="module">
        import {displayObjectInDiv} from './utils.js';
        import {drawArrow} from './drawing.js';

        const DEBUG = true;
        const TRESHOLD = 30;//value in pixels to consider a collision
        //global state object to store the system state, xs vs etc empty arrays for now
        let STATE = {
            "xs":[],
            "vs":[],
            "masses":[],
            "collisions": new Map(),
            "polygons":[],
            "interactive_arrows_endpoint":[],//This will be a [n_particles,2] array with user interactive arrows then we might use it to set specific vectors like forces or velocities
        };
       
        function debugLog(message){
            if (DEBUG){
                console.log(message);
            }
        }
        // ok so basically this is a testing playground for the contact resolution system
        // we'll start simple, particle ( represented by a circle ) to static ground/polygon contact
        // for testing we'll implement a brute force collision detection system to check the segment and particle that are in contact
        // we'll omit friction for now, just to keep things simple, and we'll consider inelastic collisions
        // so the relative velocity particle segment in the normal direction is basically clipped to zero at contact
        // we'll also consider the particle to be a point mass for now, so we'll just check the distance 
        //from the particle to the segment

        // Before implementing the physics
        // lets write some basic drawing functions with d3
        // ok so basically a function that draw a polygon
        //given an array of points
        let svg = d3.select("svg");
        function drawPolygon(svg, points, id="") {
            svg.append("polygon")
                .attr("points", points.map(p => p.join(",")).join(" "))
                .attr("fill", "none")
                .attr("stroke", "black")
                .attr("stroke-width", 2)
                .attr("id",`polygon_${id}`);
        }   

        function translateSvg(polygon_id, translation){
            let polygon = d3.select(polygon_id);
            let [x, y] = translation;
            polygon.attr("transform",`translate(${x}, ${y})`);

        }

  
        // lets make a polygon class to manage basic utilities
        // like getting the vertices, edges, normals, calculating distances etc
        class Polygon{
            constructor(svg,vertices, id=""){
                this.svg = svg;
                this.vertices = vertices;
                this.edges = this.getEdges();
                this.normals = this.getNormals();
                this.id = id;
                this.drawPolygon(svg);
            }

            updateVertices(vertices){
                this.vertices = vertices;
                this.edges = this.getEdges();
                this.normals = this.getNormals();
                this.drawPolygon(this.svg);

            }

            getCenter(){
                let n = this.vertices.length;
                let [cx,cy] = [0,0];
                for (let i = 0;i<n;i++){
                    cx += this.vertices[i][0];
                    cy += this.vertices[i][1];
                }
                cx /= n;
                cy /= n;
                return [cx,cy];
            }

            getEdges(){
                let n = this.vertices.length;
                let edges = [];
                for (let i = 0;i<n;i++){
                    let edge = [this.vertices[i],this.vertices[(i+1)%n]];
                    edges.push(edge);
                }
                return edges;
            }

            getEdgeMidpoint(edge_index){
                let edge = this.edges[edge_index];
                let [x1,y1] = edge[0];
                let [x2,y2] = edge[1];
                return [(x1+x2)/2,(y1+y2)/2];
            }

            getNormals(){
                let n = this.edges.length;
                let normals = [];
                for (let i = 0;i<n;i++){
                    let [x1,y1] = this.edges[i][0];
                    let [x2,y2] = this.edges[i][1];
                    let [dx,dy] = [x2-x1,y2-y1];
                    let normal = [dy,-dx];
                    normals.push(normal);
                }

                return normals;
            }

            getClosestPoint2Edge(point,edge){
                //checks if the point projected     
                //on the edge is inside the edge
                //if not returns the closest point on the edge
                let [xp1,xp2] = [point[0]-edge[0][0],point[1]-edge[0][1]];
                let tvec = math.subtract(edge[1],edge[0]);
                let edge_l = math.norm(tvec);
                tvec = math.divide(tvec,edge_l);
                let projection = math.dot(tvec,[xp1,xp2]);
                if (projection<0){
                    return [edge[0][0],edge[0][1]];
                }
                if (projection>edge_l){
                    return [edge[1][0],edge[1][1]];
                }
                else{
                    return math.add(math.multiply(projection,tvec),edge[0]);
                }
            }

            getDistance2Edge(point,edge){
                let closest_point = this.getClosestPoint2Edge(point,edge);
                return math.norm(math.subtract(point,closest_point));
            }


            getClosestEdge(point){
                let n = this.edges.length;
                let min_distance = Infinity;
                let closest_edge = null;

                for (let i = 0;i<n;i++){
                    let edge = this.edges[i];
                    let closest_point = this.getClosestPoint2Edge(point,edge);
                    let distance = math.norm(math.subtract(point,closest_point));
                    if (distance<min_distance){
                        min_distance = distance;
                        closest_edge = i;
                    }
                }
                return [closest_edge, min_distance];
            }

            drawPolygon(svg){
                // lets create a group for the polygon elements so we can handle normal arrows,polygon text edges as a group
                let group = svg.append("g").attr("id",`polygon_${this.id}`);
                let id_body = `polygon_body_${this.id}`;
                drawPolygon(group,this.vertices,id_body);
                //lets draw the normals
                if (DEBUG){
                let n = this.edges.length;
                for (let i = 0;i<n;i++){
                    let [x1,y1] = this.edges[i][0];
                    let [x2,y2] = this.edges[i][1];
                    let [dx,dy] = this.normals[i];
                    let [cx,cy] = [(x1+x2)/2,(y1+y2)/2];
                    let [nx,ny] = [cx+dx,cy+dy];
                    group.append("line")
                    .attr("x1",cx)
                    .attr("y1",cy)
                    .attr("x2",nx)
                    .attr("y2",ny)
                    .attr("stroke","black")
                    .attr("stroke-width",2)
                    .attr("id",`normal_${this.id}_${i}`)
                    .append("title")
                    .text(`${i}_p1[${this.edges[i][0]}]$_p2[${this.edges[i][1]}]`);
                }
            }
                //lets place a text element at the center of the polygon with the id
                // and a text at each edge with the edge index

                if (DEBUG){
                let [cx,cy] = this.getCenter();
                group.append("text")
                .attr("x",cx)
                .attr("y",cy)
                .text(this.id);
                }


            }
        }


        // lets write a Particles class to manage the particles
        class Particles{
            constructor(svg,id="",div_id_debug = null){
                this.svg = svg;
                this.id = id;
                this.div_id_debug = div_id_debug;
                this.drawParticles(this.svg);
                this.initdraggable(div_id_debug)
            }


            drawParticles(svg){
                let n = STATE.xs.length;
                let gid = `particles_${this.id}`;
                svg.select(`#${gid}`).remove();
                let group = svg.append("g").attr("id",gid);

                for (let i = 0; i<n;i++){
                    //lets create a inner group for each particle so we can handle the particle and the text as a group
                    // lets remove the previous group if it exists
                    
                    let inner_group = group.append("g").attr("id",`particle_${this.id}_${i}`);

                    inner_group.append("circle")
                    .attr("cx",STATE.xs[i][0])
                    .attr("cy",STATE.xs[i][1])
                    .attr("r",15)
                    .attr("fill","green")


                    inner_group.append("text")
                    .attr("x",STATE.xs[i][0])
                    .attr("y",STATE.xs[i][1])
                    .text(i)
                    .attr("fill","black");

                }
            }
            initdraggable(div_id_debug = null)        
            {   
                let nparticles = STATE.xs.length;
                for (let i = 0; i<=nparticles;i++){
                    let id = `particle_${this.id}_${i}`;
                    interact(`#${id}`)
                    .draggable({
                        // lets record the starting position

                        onmove: function(event){
                            let target = event.target;
                            let x = (parseFloat(target.getAttribute("data-x")) || 0) + event.dx;
                            let y = (parseFloat(target.getAttribute("data-y")) || 0) + event.dy;

                            target.style.transform = `translate(${x}px, ${y}px)`;
                            target.setAttribute("data-x", x);
                            target.setAttribute("data-y", y);
                        },
                        // end conditions
                        onend: function(event){
                            // lets use the current coordinates of the object to display
                            // the position in the info_particles div
                            let obj = event.target;
                            let circle = obj.querySelector("circle");
                            let datax = parseFloat(obj.getAttribute("data-x"));
                            let datay = parseFloat(obj.getAttribute("data-y"));
                            let x = parseFloat(circle.getAttribute("cx"))+datax;
                            let y = parseFloat(circle.getAttribute("cy"))+datay;
                            let particle_index = parseInt(obj.id.split("_")[2]);
                            STATE.xs[particle_index] = [x,y];
                            

                            if (div_id_debug){
                                let parentDiv = document.getElementById(div_id_debug);
                                let p = (parentDiv.querySelector(`#${id}`) || document.createElement("p"));
                                parentDiv.appendChild(p);
                                p.id = id;
                                p.innerHTML = `Particle ${i}: x: ${x}, y: ${y}`;
                        }
                }
              
            });
        }

            }
        }


        //Lets write the CollisionHandler to manage the collisions
        // we must uncouple the collision detection algorithm and data from the drawing functions
        // so we must make a collision drawer class that  handles the drawing
        

        class CollisionHandler{
            constructor(){
                // We'll store collisions as key value pairs, with id particle_index_edge_index_polygon_id
                // this way it will be easy to check if a collision is already in the map and to remove if
                // it's been resolved

            }
            detectNewCollisions(collisions, xs, polygons, treshold){
                let n = xs.length;
                let m = polygons.length;    


                //the colliding particles
                let new_collisions = new Map();
               
                for (let i = 0;i<n;i++){
                    for (let j = 0;j<m;j++){
                        
                        let point = xs[i];
                        let polygon = polygons[j];
                        let [closest_edge,distance] = polygon.getClosestEdge(point);
                       // console.log(`Particle ${i} with position ${point} closest edge ${closest_edge} distance ${distance}`);
                        if (distance<treshold){
                            let collision_id = `${i}_${closest_edge}_${polygon.id}`;
                            //if the collision is not already in the map we'll add it
                            if (!collisions.has(collision_id)){        
                                new_collisions.set(collision_id,[i,closest_edge,polygon]);
                            };
                        };
                            }
                
                        }
                return new_collisions;
                    };
                


            detectResolvedCollisions(collisions, xs , treshold){
                //we'll give the resolved collisions, the ones that are not in contact anymore

                let resolved_collisions = new Map();
                let collisions_keys = Array.from(collisions.keys());
                for (let i = 0;i<collisions_keys.length;i++){
                    let collision = collisions.get(collisions_keys[i])
                    let [particle_index,edge_index,polygon] = collision;
                    let collision_id = `${particle_index}_${edge_index}_${polygon.id}`;
                    let current_distance = polygon.getDistance2Edge(xs[particle_index],polygon.edges[edge_index]);
                    if (current_distance>treshold){
                        resolved_collisions.set(collision_id,collision);
                    }
                }

               return resolved_collisions;   
            }
        

            updateCollisionsMap(collisions, xs, polygons, threshold){
                
                let new_collisions = this.detectNewCollisions(collisions, xs, polygons, threshold);
                let resolved_collisions = this.detectResolvedCollisions(collisions, xs, threshold);
                let new_collisions_keys = Array.from(new_collisions.keys());
   
                for (let i = 0;i<new_collisions_keys.length;i++){
                    // lets throw an exception if the collision is already in the map
                    if (collisions.has(new_collisions_keys[i])){
                        throw `Collision ${new_collisions_keys[i]} already in the map`;
                    }

                    //lets avoid corner issues by allowing only one collision per particle
                    //if the particle is already in a collision we'll remove the previous collision
                    let [particle_index,edge_index,polygon] = new_collisions.get(new_collisions_keys[i]);
                    let keys = Array.from(collisions.keys());
                    for (let j = 0;j<keys.length;j++){
                        let [p_index,_1,_2] = collisions.get(keys[j]);
                        if (p_index == particle_index){
                            //lets add the previous collision to the resolved collisions
                            resolved_collisions.set(keys[j],collisions.get(keys[j]));
                            collisions.delete(keys[j]);
                        }
                    }
                    collisions.set(new_collisions_keys[i],new_collisions.get(new_collisions_keys[i]));
                }


                let resolved_collisions_keys = Array.from(resolved_collisions.keys());
                for (let i = 0;i<resolved_collisions_keys.length;i++){
                    
                    collisions.delete(resolved_collisions_keys[i]);
                }
                
                return [collisions,new_collisions,resolved_collisions];
             
            }


        }

        //now lets add the collision drawer class

        class CollisionDrawer{
            constructor(svg){
                this.svg = svg;
            }

            drawCollisions(new_collisions, resolved_collisions){

                if (new_collisions.size>0){
                    let keys = Array.from(new_collisions.keys());
                    for (let i = 0;i<keys.length;i++){
                        let collision = new_collisions.get(keys[i]);
                        this.enterCollision(collision);
                    }
                };

                if (resolved_collisions.size>0){
                let keys_resolved = Array.from(resolved_collisions.keys());
                for (let i = 0;i<keys_resolved.length;i++){
                    let collision = resolved_collisions.get(keys_resolved[i]);
                    this.exitCollision(collision);
                    }
                };
            }

            enterCollision(collision){
                //We'll change the edge normal to red and the particle to red when in contact
                let [particle_index,edge_index,polygon] = collision;
                let particle = d3.select(`#particle_1_${particle_index}`);
                let normal = d3.select(`#normal_${polygon.id}_${edge_index}`);

                particle.attr("fill","red");
                normal.attr("stroke","red");

                

            }

            exitCollision(collision){
                //We'll change the edge normal to black and the particle to green when in contact
                let [particle_index,edge_index,polygon] = collision;
                let particle = d3.select(`#particle_1_${particle_index}`);
                let normal = d3.select(`#normal_${polygon.id}_${edge_index}`);
                particle.attr("fill","green");
                normal.attr("stroke","black");
            }

        }



        // Add a text element to display the mouse position

        function svgmousecallback(event,svg, text_display){
            
            let svg_rect = svg.node().getBoundingClientRect();
            let mouse_position = [event.clientX - svg_rect.left, event.clientY - svg_rect.top];
            text_display.text(`Mouse position : ${mouse_position} clientX: ${event.clientX} clientY: ${event.clientY} svg_rect.left: ${svg_rect.left} svg_rect.top: ${svg_rect.top}`);
        }
        let mousePositionText = svg.append("text")
            .attr("x", 10)
            .attr("y", 20);

        if (DEBUG){
        svg.node().addEventListener("mousemove", function(event){
            svgmousecallback(event, svg, mousePositionText);
        })
            };

    
    // Lets prototype the unequality constraint solver
    // I'll sketch the basic idea here
    /*
        We get the map object with the active constraints
        We'll make in the first iteration all collisions to be perfectly inelastic so we make the normal relative
        velocity to be zero
        We build the contact jacobian matrix with the normals of the edges in contact
        We must solve the system A*lambda = b  where A = J*M^{-1}*J^T  and 
            b = -dotJv - J*M^{-1}*Fext - alpha*Jv - beta*C
            in this test case there will only be contact constraints, and the segments are piece wise linear
            so dotJ = 0 (second derivative of the constraint is zero, well actually it's a dirac delta function, but
            we'll approximate it to zero) we'll relly on baumgarte stabilization to act as a soft constraint/penalty
            We clip the lambda values to be positive, as we're dealing with contact forces
            we update the velocities with all the non frictional forces
            and we calculate the friction impulse ( with force in the friction cone), and we make sure
            that delta v caused by the friction acts opposite to the relative velocity
            if deltav_friction*v_tangent>0 we'll make deltav_friction = -v_tangent
            we'll update the velocities with the frictional forces
            we'll update the positions with the new velocities

            At this iteration all contact surfaces will belong to platforms/ground, static objects so
            \dot{n} = 0
    */

    function solveContactConstraints(collisions, xs, vs, polygons, masses){
        // J will be a [n_constraints, n_particles*2] matrix
        //xs [n_particles,2] array, same with vs, masses a [n_particles] array
        let n_constraints = collisions.size;
        let n_particles = xs.length;
        let J = math.zeros(n_constraints,n_particles*2,"sparse");
        let fext = math.zeros(n_particles*2);
        let g = 100;
        let constraint_values = math.zeros(n_constraints);
        let alpha = 10;
        let beta = 10;
        let friction_coefficient = 0.1;
        let friction_forces = math.zeros(n_particles*2);

        //friction forces are F_f = -friction_coefficient*lambda(-v_tangent)/(|v_tangent|+epsilon)
        //v_tangent = v - dot(v,n)*n
        // we calculate now (-v_tangent)/(|v_tangent|+epsilon) and then we'll multiply by friction_coefficient*lambda
        let keys = Array.from(collisions.keys());
  
        for (let i = 0;i<n_constraints;i++){
            let collision = collisions.get(keys[i]);
            let [particle_index,edge_index,polygon] = collision;
            let normal = polygon.normals[edge_index];
            J.subset(math.index(i,particle_index*2),normal[0]);
            J.subset(math.index(i,particle_index*2+1),normal[1]);
            //lets calculate the constraint value, r_{particle} - r_{edge} dot normal
            let particle_position = xs[particle_index];
            let edge_point_1 = polygon.edges[edge_index][0];
            let rp = [particle_position[0]-edge_point_1[0],particle_position[1]-edge_point_1[1]];
            let val = math.dot(rp,normal);
            constraint_values.subset(math.index(i),val);
            // now lets calculate the friction forces
            let v = [vs[particle_index][0],vs[particle_index][1]];
            let dotv = math.dot(v,normal);
            let vt = [v[0]-dotv*normal[0],v[1]-dotv*normal[1]];
            let vt_norm = math.norm(vt);
            let epsilon = 0.0001;
            let friction_force = math.multiply(-friction_coefficient/(vt_norm+epsilon),vt);
            friction_forces.subset(math.index(particle_index*2),friction_force[0]);
            friction_forces.subset(math.index(particle_index*2+1),friction_force[1]);

        }

        
        let Minv = math.zeros(n_particles*2,n_particles*2,"sparse");
        for (let i = 0;i<n_particles;i++){
            let mass = masses[i];
            Minv.subset(math.index(i*2,i*2),1/mass);
            Minv.subset(math.index(i*2+1,i*2+1),1/mass);
            //gravity has [0,1] direction ( y axis is positive downwards)
            fext.subset(math.index(i*2+1),mass*g);
        }
        let Jt = math.transpose(J);
        let A = math.multiply(J,math.multiply(Minv,Jt));
        // lets calculate the different summands on b by parts
        //dotJv = 0 so we'll skip that
        
        let vmatrix = math.flatten( math.matrix(vs));
        let part1 = math.multiply(alpha,math.multiply(J,vmatrix));
        let part2 = math.multiply(J,math.multiply(Minv,fext));
        let part3 = math.multiply(beta,constraint_values).reshape([n_constraints,1]);
        let b = math.add(part1, math.add(part2,part3));
        b = math.multiply(b,-1);
        if (DEBUG){
            console.log(`A: ${A}`);
            console.log(`b: ${b}`);
        }
        let lambda = math.lusolve(A,b );
        // lets copy the preclipped lambda values
        let lambda_unclipped = math.clone(lambda);
        //lets clip the lambda values to be positive
        // the following for loop is not working, the exception is thrown
        //we {actual: 1, expected: 2, relation: undefined, message: 'Dimension mismatch (1 != 2)', stack: 'Error\n    at new we (https://cdnjs.cloudflare.com/… (http://127.0.0.1:5500/test_contact.html:581:26)'}
        //lets check the lambda values
        lambda = math.flatten(lambda).toArray();
        for (let i = 0; i < n_constraints; i++) {
            if (lambda[i] < 0) {
                lambda[i] = 0;
            }
                };

 
        let constraint_forces = math.multiply(Jt,lambda);

        //lets multiplicate the friction forces by the lambda values
        for (let i = 0;i<n_constraints;i++){
            let collision = collisions.get(keys[i]);
            let [particle_index,edge_index,polygon] = collision;
            let friction_force_x = friction_forces.subset(math.index(particle_index*2))*lambda[i];
            let friction_force_y = friction_forces.subset(math.index(particle_index*2+1))*lambda[i];
            friction_forces.subset(math.index(particle_index*2),friction_force_x);
            friction_forces.subset(math.index(particle_index*2+1),friction_force_y);
            

        }
  
        // the timestep is in an outer scope , lets pack every info calculated here into an output dict
        let fext_array = fext.reshape([n_particles,2]).toArray();
        let friction_forces_array = friction_forces.reshape([n_particles,2]).toArray();
        let constraint_forces_array = constraint_forces.reshape([n_particles,2]).toArray();
        let output = {
            "J":J,
            "fext":fext_array,
            "g":g,
            "constraint_values":constraint_values,
            "alpha":alpha,
            "beta":beta,
            "friction_coefficient":friction_coefficient,
            "friction_forces":friction_forces_array,
            "constraint_forces":constraint_forces_array,
            "Minv":Minv,
            "A":A,
            "b":b,
            "lambda":lambda,
            "lambda_unclipped":lambda_unclipped,
        };
        if (DEBUG){
            console.log("OUTPUT solveconstraints",output);
        }


        //if debug lets draw external,frictional and constraint forces in diferent colors
        //drawArrow signature drawArrow(svg, x1, y1, x2, y2, arrowId,class_name = "arrow", color="black")
        

        return output;


    }



    // Lets write a semi-implicit euler integrator
    function step(STATE,fext,friction_forces,constraint_forces,dt){
        let xs = STATE.xs;
        let vs = STATE.vs;
        let masses = STATE.masses;
        let nparticles = xs.length;

        for (let i = 0;i<nparticles;i++){
            let [x,y] = xs[i];
            let [vx,vy] = vs[i];
            let mass = masses[i];
            let [fx,fy] = fext[i];
            let [fcx,fcy] = constraint_forces[i];
            let [ffx,ffy] = friction_forces[i];
            let ax = (fx+fcx+ffx)/mass;
            let ay = (fy+fcy+ffy)/mass;
            let vxnew = vx + ax*dt;
            let vynew = vy + ay*dt;
            let xnew = x + vxnew*dt;
            let ynew = y + vynew*dt;
            xs[i] = [xnew,ynew];
            vs[i] = [vxnew,vynew];
        }
    }

    //lets make a function to draw some outputs of the solveContactConstraints function

    function drawContactConstraints(STATE,output, svg){

        // lets draw external forces, constraint forces and frictional forces

        let fext = output.fext;
        let constraint_forces = output.constraint_forces;
        let friction_forces = output.friction_forces;
        let xs = STATE.xs;
        let nparticles = xs.length;

        for (let i = 0;i<nparticles;i++){
            let [xo,yo] = xs[i];
            let [xf,yf] = [xo+fext[i][0],yo+fext[i][1]];
            drawArrow(svg,xo,yo,xf,yf,`arrow_fext_${i}`,"arrow","green");
            let [xc,yc] = [xo+constraint_forces[i][0],yo+constraint_forces[i][1]];
            drawArrow(svg,xo,yo,xc,yc,`arrow_constraint_${i}`,"arrow","blue");
            let [xfc,yfc] = [xo+friction_forces[i][0],yo+friction_forces[i][1]];
            drawArrow(svg,xo,yo,xfc,yfc,`arrow_friction_${i}`,"arrow","red");
        }

    }

    // lets write a class for interactive arrows, the idea is to move around the endpoint of the arrow to set orientation and magnitude
    // an arrow instance will be associated with a particle, so the origin of the arrow will be the particle position
    // we'll store the arrow end in the STATE object, in the interactive_arrows array, then the specific code logic
    // will set some specific vector like a force or a velocity using this arrow

    class InteractiveArrow{
        constructor(svg,particle_index){
            this.svg = svg;
            this.particle_index = particle_index;
            this.draw(svg,particle_index);
            this.initdraggable();
        }
        draw(svg,particle_index){
            let [xo,yo] = STATE.xs[particle_index];
            let [xf,yf] = STATE.interactive_arrows_endpoint[particle_index];

            svg.select(`#arrow_interactive_${particle_index}`).remove();
            svg.append("line")
            .attr("x1", xo)
            .attr("y1", yo)
            .attr("x2", xf)
            .attr("y2", yf)
            .attr("stroke", "black")
            .attr("stroke-width", 2)
            .attr("id", `arrow_interactive_${particle_index}`);

            

        }
        initdraggable(){
            let id = `arrow_interactive_${this.particle_index}`;
            let i = this.particle_index;
            let draw = this.draw;
            let svg = this.svg;
            interact(`#${id}`)
            .draggable({
                onmove: function(event){
                    let target = event.target;
                    let x = event.dx;
                    let y = event.dy;
                    let x2 = parseFloat(target.getAttribute("x2"));
                    let y2 = parseFloat(target.getAttribute("y2"));
                    target.setAttribute("x2", x2+event.dx);
                    target.setAttribute("y2", y2+event.dy);

                    STATE.interactive_arrows_endpoint[i] = [x2,y2];
                    draw(svg,i);
        }
        });
    }
    }

    

    
    // *********** CREATING AND DRAWING THE OBJECTS ***************
    let points_particles = [[50, 50], [150, 50], [250, 50], [350, 50], [450, 50]];
    

    STATE.xs = points_particles;
    STATE.vs = [[0,0],[0,0],[0,0],[0,0],[0,0]];
    STATE.masses = [1,1,1,1,1];
    let particles = new Particles(svg, "1", "info_particles");
   // STATE.interactive_arrows_endpoint = points_particles.map(p => [p[0]+20,p[1]+20]);
    // lets test the interactive arrow
   // let interactive_arrow = new InteractiveArrow(svg,0);


 
    let points_polygon = [[100, 100], [200, 100],
                    [200, 200], [100, 200],
                    [60,160]];
    points_polygon = points_polygon.map(p => [p[0]+200,p[1]+200])


    let polygon = new Polygon(svg,points_polygon, "1");
    STATE.polygons = [polygon];
   



    //*********** CREATING THE COLLISION HANDLER ***************
    let collisionHandler = new CollisionHandler();
    let collisionDrawer = new CollisionDrawer(svg);

    //lets write a collision callback, we'll call mainfunction of collision handler
    // additionally we'll call the solveContactConstraints function
    // with point_particles as xs, vs zero, masses 1, polygons as polygons
    //we'll output if debug the results of solvecontactconstraitns to div debug_solve_constraints
    // using the displayObjectInDiv function with signature displayObjectInDiv(obj, div_output_id, id_prefix="text_debug")

    window.STATE = STATE;
    window.collisionDrawer = collisionDrawer;
    window.collisionHandler = collisionHandler;

    function MainCallback(){
        if (DEBUG){
            console.log("MainCallback");
        }
        let [_,new_collisions,resolved_collisions] = collisionHandler.updateCollisionsMap(STATE.collisions, STATE.xs, STATE.polygons, TRESHOLD);
        collisionDrawer.drawCollisions(new_collisions,resolved_collisions);
        if (DEBUG){
            console.log("NEW COLLISIONS",new_collisions);
            console.log("RESOLVED COLLISIONS",resolved_collisions);
            console.log("COLLISIONS",STATE.collisions)
        }
        //lets call the solveContactConstraints function if there are collisions

        let n_active_collisions = STATE.collisions.size;

        let output = {
            fext:math.zeros(STATE.xs.length,2).toArray(),
            friction_forces:math.zeros(STATE.xs.length,2).toArray(),
           constraint_forces:math.zeros(STATE.xs.length,2).toArray(),}
        if (n_active_collisions>0){
            output = solveContactConstraints(STATE.collisions,STATE.xs,
                                                STATE.vs,STATE.polygons,
                                                STATE.masses);
            if (DEBUG){
                displayObjectInDiv(output,"debug_solve_constraints");
                drawContactConstraints(STATE,output, svg)
            }
        }

        //lets update the positions and velocities
        step(STATE,
        output.fext,
        output.friction_forces,
        output.constraint_forces,
        0.1);

        //lets update the particles
        particles.drawParticles(svg);

        let divState = document.getElementById("state");
        displayObjectInDiv(STATE, "state");

    }
    //lets add the event listener to the button
    let button = document.getElementById("button_main");
    button.addEventListener("click",MainCallback);
    //setInterval(MainCallback,1000);
    
    </script>
</body>
</html>