!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.MinimalSolver=e():t.MinimalSolver=e()}(window,function(){return function(t){var e={};function r(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,s){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(s,i,function(e){return t[e]}.bind(null,i));return s},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";r.r(e),r.d(e,"step",function(){return A}),r.d(e,"Drawer",function(){return C});class s{constructor(t,e,r){this.idx1=t,this.idx2=e,this.distance=r}getType(){return"distance"}getParticleIndices(){return[this.idx1,this.idx2]}distfunc(t,e,r,s){return Math.sqrt((r-t)**2+(s-e)**2)}getDistanceParticles(t){if(2!=t[0].length)throw new Error("xarray must be a 2D array");let e=t[this.idx1][0],r=t[this.idx1][1],s=t[this.idx2][0],i=t[this.idx2][1];return this.distfunc(e,r,s,i)}getConstraintValue(t,e=!0){return e?this.getDistanceParticles(t)**2-this.distance**2:this.getDistanceParticles(t)-this.distance}getJacobianParticles(t){let e=t[this.idx1][0],r=t[this.idx1][1],s=t[this.idx2][0],i=t[this.idx2][1];return[[e-s,r-i],[s-e,i-r]]}getDotJacobianParticles(t){let e=t[this.idx1][0],r=t[this.idx2][0],s=t[this.idx1][1],i=t[this.idx2][1];return[[e-r,s-i],[r-e,i-s]]}}class i{constructor(t,e,r){if(2!=e.length)throw new Error("pin_point must be a 2D array");this.idx=t,this.pin_point=e,this.distance=r}getType(){return"pin"}getPinPoint(){return this.pin_point}getParticleIndices(){return[this.idx]}distfunc(t,e,r,s){return Math.sqrt((r-t)**2+(s-e)**2)}getDistancePoint(t){if(2!=t[0].length)throw new Error("xarray must be a 2D array");let e=t[this.idx][0],r=t[this.idx][1],s=this.pin_point[0],i=this.pin_point[1];return this.distfunc(e,r,s,i)}getConstraintValue(t,e=!0){return e?this.getDistancePoint(t)**2-this.distance**2:this.getDistancePoint(t)-this.distance}getJacobianParticles(t){let e=t[this.idx][0],r=t[this.idx][1];return[[e-this.pin_point[0],r-this.pin_point[1]]]}getDotJacobianParticles(t){return[[t[this.idx][0],t[this.idx][1]]]}}class n{constructor(t,e,r){this.particle_index=t,this.edge_index=e,this.polygon=r}getType(){return"contact"}getParticleIndices(){return[this.particle_index]}getConstraintValue(t){let e=t[this.particle_index];return this.polygon.getClosestEdgeNormalProjection(e)}getJacobianParticles(t){return[this.polygon.getNormal(this.edge_index)]}getDotJacobianParticles(t){return[[0,0]]}}class o{constructor(t,e){this.particle_indices=t,this.force=e}getForceArray(t,e,r){if(!Array.isArray(t)||!Array.isArray(e)||!Array.isArray(r))throw new Error("xarray, varray and masses should be arrays");let s=t.length,i=this.particle_indices.length,n=math.zeros(s,2,"sparse");for(let t=0;t<i;t++){let e=this.particle_indices[t],r=this.force,s=r[0],i=r[1];n.set([e,0],s),n.set([e,1],i)}return n.toArray()}}class a{constructor(t,e=9.8,r=[0,-1]){this.g=e,this.particle_indices=t,this.direction=r}getForceArray(t,e,r){if(!Array.isArray(t)||!Array.isArray(e)||!Array.isArray(r))throw new Error("xarray, varray and masses should be arrays");let s=t.length,i=this.particle_indices.length,n=math.zeros(s,2,"sparse");for(let t=0;t<i;t++){let e=this.particle_indices[t],s=r[e],i=this.g*s,o=i*this.direction[0],a=i*this.direction[1];n.set([e,0],o),n.set([e,1],a)}return n.toArray()}}class l{constructor(t,e){this.particle_indices=t,this.damping_coefficient=e}getForceArray(t,e,r){if(!Array.isArray(t)||!Array.isArray(e)||!Array.isArray(r))throw new Error("xarray, varray and masses should be arrays");let s=t.length,i=this.particle_indices.length,n=math.zeros(s,2,"sparse");for(let t=0;t<i;t++){let r=this.particle_indices[t],s=this.damping_coefficient,i=e[r],o=-s*i[0],a=-s*i[1];n.set([r,0],o),n.set([r,1],a)}return n.toArray()}}class c{constructor(t,e,r,s){this.particle_indices=[t,e],this.spring_constant=r,this.rest_length=s}getForceArray(t,e,r){if(!Array.isArray(t)||!Array.isArray(e)||!Array.isArray(r))throw new Error("xarray, varray and masses should be arrays");let s=t.length,i=(this.particle_indices.length,math.zeros(s,2,"sparse")),n=this.particle_indices[0],o=this.particle_indices[1],a=t[n],l=t[o],c=a[0],h=a[1],d=l[0],p=l[1],u=Math.sqrt((d-c)**2+(p-h)**2),g=this.spring_constant*(u-this.rest_length),m=g*(d-c)/u,f=g*(p-h)/u;return i.set([n,0],m),i.set([n,1],f),i.set([o,0],-m),i.set([o,1],-f),i.toArray()}}class h{constructor(t,e,r,s){this.particle_indices=[t],this.spring_constant=r,this.rest_length=s,this.fixed_point=e}getForceArray(t,e,r){if(!Array.isArray(t)||!Array.isArray(e)||!Array.isArray(r))throw new Error("xarray, varray and masses should be arrays");let s=t.length,i=(this.particle_indices.length,math.zeros(s,2,"sparse")),n=this.particle_indices[0],o=t[n],a=o[0],l=o[1],c=this.fixed_point[0],h=this.fixed_point[1],d=Math.sqrt((c-a)**2+(h-l)**2),p=this.spring_constant*(d-this.rest_length),u=p*(c-a)/d,g=p*(h-l)/d;return i.set([n,0],u),i.set([n,1],g),i.toArray()}}function d(t,e,r,s){let i=e.length,n=math.zeros(i,2,"sparse");for(let i of t){let t=i.getForceArray(e,r,s);n=math.add(n,t)}return n}console.log("solver.js loaded","PENDING MODIFY HANDLING OF CONTACT CONSTRAINTS, NEEDED AN ADDITIONAL ITERATION AFTER CLIPPING LAGRANGE MULTIPLIERS (ACTIVE SET METHOD)");class p{constructor(t,e){this.vertices=t,this.edges=this.getEdges(),this.id=e}updateVertices(t){this.vertices=t,this.edges=this.getEdges()}getCenter(){this.vertices.length;let[t,e]=math.mean(this.vertices,0);return[t,e]}getEdges(){let t=this.vertices.length,e=[];for(let r=0;r<t;r++){let s=[this.vertices[r],this.vertices[(r+1)%t]];e.push(s)}return e}getEdgeMidpoint(t){let e=this.edges[t],[r,s]=e[0],[i,n]=e[1];return[(r+i)/2,(s+n)/2]}getNormal(t){let e=this.edges[t],[r,s]=e[0],[i,n]=e[1],[o,a]=[i-r,n-s],l=[-a,o],c=math.norm(l);return l=[l[0]/c,l[1]/c]}getNormals(){let t=this.edges.length,e=[];for(let r=0;r<t;r++){let t=r,s=this.getNormal(t);e.push(s)}return e}getClosestPoint2Edge(t,e){let[r,s]=[t[0]-e[0][0],t[1]-e[0][1]],i=math.subtract(e[1],e[0]),n=math.norm(i);i=math.divide(i,n);let o=math.dot(i,[r,s]);return o<0?[e[0][0],e[0][1]]:o>n?[e[1][0],e[1][1]]:math.add(math.multiply(o,i),e[0])}getClosestEdgeNormalProjection(t){let[e,r]=this.getClosestEdge(t),s=this.getEdgeMidpoint(e),i=math.subtract(t,s),n=this.getNormal(e);return math.dot(n,i)}getClosestEdgeNormalProjectionVector(t){let e=this.getClosestEdgeNormalProjection(t);return math.multiply(e,normal).toArray()}getDistance2Edge(t,e){let r=this.getClosestPoint2Edge(t,e);return math.norm(math.subtract(t,r))}getClosestEdge(t){let e=this.edges.length,r=1/0,s=null;for(let i=0;i<e;i++){let e=this.edges[i],n=this.getClosestPoint2Edge(t,e),o=math.norm(math.subtract(t,n));o<r&&(r=o,s=i)}return[s,r]}isInteriorPoint(t){let e=this.edges.length,r=0,s=t[0],i=t[1];for(let t=0;t<e;t++){let e=this.edges[t],[n,o]=e[0],[a,l]=e[1];i<Math.min(o,l)||i>=Math.max(o,l)||s<=n+(i-o)*(a-n)/(l-o)&&r++}return r%2==1}}class u{constructor(){}_detectNewCollisions(t,e,r,s){let i=e.length,n=r.length,o=new Map;for(let a=0;a<i;a++)for(let i=0;i<n;i++){let n=e[a],l=r[i],[c,h]=l.getClosestEdge(n);if(h<s||l.isInteriorPoint(n)){let e=`${a}_${c}_${l.id}`;t.has(e)||(o.set(e,[a,c,l]),console.log(`NEW COLLISION :Particle ${a} with position ${n} closest edge ${c} distance ${h} threshold ${s}`))}}return o}_detectResolvedCollisions(t,e,r){let s=new Map,i=Array.from(t.keys());for(let n=0;n<i.length;n++){let o=t.get(i[n]),[a,l,c]=o,h=`${a}_${l}_${c.id}`,d=e[a];if(!c.isInteriorPoint(d)){let t=c.getDistance2Edge(d,c.edges[l]);t>r&&(s.set(h,o),console.log(`RESOLVED COLLISION:Particle ${a} with position ${e[a]} edge ${l} distance ${t} treehold ${r}`))}}return s}_updateCollisionsMap(t,e,r,s){let i=this._detectNewCollisions(t,e,r,s),n=this._detectResolvedCollisions(t,e,s),o=Array.from(i.keys());for(let e=0;e<o.length;e++){if(t.has(o[e]))throw`Collision ${o[e]} already in the map`;let[r,s,a]=i.get(o[e]),l=Array.from(t.keys());for(let e=0;e<l.length;e++){let[s,i,o]=t.get(l[e]);s==r&&(n.set(l[e],t.get(l[e])),t.delete(l[e]))}t.set(o[e],i.get(o[e]))}let a=Array.from(n.keys());for(let e=0;e<a.length;e++)t.delete(a[e]);return[t,i,n]}updateCollisions(t,e){let[r,s,i]=y(t),n=t.collisions,o=t.xs,a=new Map;n.forEach(t=>{let e=t[0]+"_"+t[1]+"_"+t[2],r=[t[0],t[1],i[t[2]]];a.set(e,r)});let[l,c,h]=this._updateCollisionsMap(a,o,i,e),d=Array.from(l.values()),p=Array.from(c.values()),u=Array.from(h.values());return[d=d.map(t=>[t[0],t[1],t[2].id]),p=p.map(t=>[t[0],t[1],t[2].id]),u=u.map(t=>[t[0],t[1],t[2].id])]}}function g(t,e,r){if(!Array.isArray(t)||!Array.isArray(e)||!Array.isArray(r))throw new Error("constraints, xarray and varray should be arrays");const s=t.length,i=e.length,n=math.zeros(s,2*i,"sparse"),o=math.zeros(s,2*i,"sparse");for(let i=0;i<s;i++){let s=t[i],a=s.getParticleIndices(),l=s.getJacobianParticles(e),c=s.getDotJacobianParticles(r);if(a.length!==l.length)throw new Error("The number of particles in the constraint is not equal to the number of jacobian particles");if(a.length!==c.length)throw new Error("The number of particles in the constraint is not equal to the number of dot jacobian particles");for(let t=0;t<a.length;t++){let e=a[t],r=l[t];if(2!==r.length)throw new Error("The jacobian particle should have 2 components");let s=r[0],h=r[1];n.set([i,2*e],s),n.set([i,2*e+1],h);let d=c[t];if(2!==d.length)throw new Error("The dot jacobian particle should have 2 components");let p=d[0],u=d[1];o.set([i,2*e],p),o.set([i,2*e+1],u)}}return[n,o]}function m(t,e,r,s,i,n,o,a=0,l=0,c=!0){if(!math.isMatrix(t)||!math.isMatrix(e)||!math.isMatrix(i))throw new Error("J, dot_J and external_forces should be mathjs matrices");if(!Array.isArray(r)||!Array.isArray(s)||!Array.isArray(n))throw new Error("xarray, varray and masses should be arrays");r.length;let h=t.size()[0],d=math.matrix(n.map(t=>[1/t,1/t])).reshape([-1]);d=math.diag(d,"sparse");let p=math.multiply(t,math.multiply(d,math.transpose(t)));if(p.size()[0]!==h||p.size()[1]!==h)throw new Error("The A matrix should have the same number of constraints");let u=math.matrix(o.map(t=>t.getConstraintValue(r))),g=math.flatten(s);i=math.flatten(i);let m=math.multiply(e,g),f=math.multiply(t,math.multiply(d,i)),y=math.multiply(a,math.multiply(t,g)),_=math.multiply(l,u).reshape([h,1]),A=math.add(math.add(m,f),math.add(y,_));if(A=math.multiply(A,-1),h>0){let t=1e-6,e=math.identity(h);p=math.add(p,math.multiply(t,e))}let x=math.lusolve(p,A).reshape([-1]);if(c){let t=o.map((t,e)=>[t.getType(),e]).filter(t=>"contact"===t[0]).map(t=>t[1]);for(let e=0;e<t.length;e++){let r=t[e];x.get([r])<0&&x.set([r],0)}}let w=function(t,e,r){let s=t.length,i=r.size()[1]/2,n=math.zeros(i,2),o=math.zeros(i,2),a=math.zeros(i,2),l=math.zeros(i,2);for(let c=0;c<s;c++){let s=t[c],h=e[c],d=r.subset(math.index(c,math.range(0,2*i))),p=math.multiply(math.transpose(d),h).reshape([i,2]);n=math.add(n,p),"distance"===s.getType()&&(o=math.add(o,p)),"pin"===s.getType()&&(a=math.add(a,p)),"contact"===s.getType()&&(l=math.add(l,p))}return{distance_forces:o.toArray(),pin_forces:a.toArray(),contact_forces:l.toArray(),constraint_forces:n.toArray()}}(o,x.toArray(),t);return{constraintForces:w.constraint_forces,lagrange_multipliers:x.toArray(),constraints_vals:u.toArray(),contact_forces:w.contact_forces,pin_forces:w.pin_forces,distance_forces:w.distance_forces}}function f(t,e,r,s,i){let n=math.zeros(e.length,2);if(t.length!==r.length)throw new Error("The number of lagrange multipliers should be equal to the number of collisions");for(let o=0;o<r.length;o++){let[a,l,c]=r[o],h=s[c].getNormal(l),d=e[a],p=math.subtract(d,math.multiply(math.dot(h,d),h)),u=math.norm(p),g=t[o],m=1e-6,f=math.multiply(-i*g/(u+m),p);n.set([a,0],f[0]),n.set([a,1],f[1])}return n.toArray()}function y(t){let e=["constraints_distance","constraints_pin","collisions","polygons","xs","vs","masses"];for(let r of e)if(!t.hasOwnProperty(r))throw new Error(`The STATE object must have the key ${r}`);let r=t,d=r.constraints_distance.map(t=>new s(t[0],t[1],t[2])),u=r.constraints_pin.map(t=>new i(t[0],t[1],t[2])),g=function(t,e){let r=[];for(let[s,i,o]of t){let t=new p(e[o],o),a=new n(s,i,t);r.push(a)}return r}(r.collisions,r.polygons),m=r.polygons.map((t,e)=>new p(t,e)),f=d.concat(u).concat(g),y=r.xs.length,_=Array.from(Array(y).keys()),A=[];return r.hasOwnProperty("constant_forces")&&(A=r.constant_forces.map(t=>new o([t[0]],t[1]))),r.hasOwnProperty("gravity")&&A.push(new a(_,r.gravity[0],r.gravity[1])),r.hasOwnProperty("damping")&&(A=A.concat(r.damping.map(t=>new l(t[0],t[1])))),r.hasOwnProperty("springs")&&(A=A.concat(r.springs.map(t=>new c(t[0],t[1],t[2],t[3])))),r.hasOwnProperty("springs2points")&&(A=A.concat(r.springs2points.map(t=>new h(t[0],t[1],t[2],t[3])))),[f,A,m]}function _(t,e,r=null){let s=["collisionThreshold","muFriction","alpha","beta"];for(let t of s)if(!e.hasOwnProperty(t))throw new Error(`The PARAMETERS object must have the key ${t}`);let i=t,[n,o,a]=(JSON.parse(JSON.stringify(t.collisions)),y(t)),l=d(o,i.xs,i.vs,i.masses),c=math.zeros(i.xs.length,2);if(null!==r)for(let e of r){let r=e(t);c=math.add(c,r)}function h(t,e,r){let[s,i,n]=y(t),o=t,[a,l]=g(s,o.xs,o.vs),c=m(a,l,o.xs,o.vs,r,o.masses,s,e.alpha,e.beta,!1),h=s.map((t,e)=>[t.getType(),e]).filter(t=>"contact"===t[0]).map(t=>t[1]).map(t=>c.lagrange_multipliers[t]).map((t,e)=>[t,e]).filter(t=>t[0]<0).map(t=>t[1]);return[c,h,a,l]}l=math.add(l,c);let p=!0,[_,A,x,w]=[null,[],null,null];for(;p;)if([_,A,x,w]=h(t,e,l),0===A.length)p=!1;else{let e=i.collisions.filter((t,e)=>!A.includes(e));t.collisions=e}[n,o,a]=y(t);let b=n.map((t,e)=>[t.getType(),e]).filter(t=>"contact"===t[0]).map(t=>t[1]).map(t=>_.lagrange_multipliers[t]),v=f(b,i.vs,i.collisions,a,e.muFriction),E=_.constraintForces,P=_.contact_forces,$=math.add(math.add(l,E),v).toArray(),C=$.map((t,e)=>[t[0]/i.masses[e],t[1]/i.masses[e]]),I=e.dt,T=math.add(i.vs,math.multiply(I,C)),O=math.add(i.xs,math.multiply(I,T)),M=new u,S={xs:O,vs:T,time:i.time+I,friction_forces:v,external_forces:l.toArray(),constraint_forces:E,contact_forces:P,actuator_forces:c.toArray(),total_forces:$,lagrange_multipliers:_.lagrange_multipliers,lagrange_multipliers_contact:b,constraints_vals:_.constraints_vals,collisions:t.collisions,J:x.toArray(),dot_J:w.toArray()},[k,N,j]=M.updateCollisions(t,e.collisionThreshold);S.collisions=k,S.new_collisions=N,S.resolved_collisions=j;for(let e in t)S.hasOwnProperty(e)||(S[e]=t[e]);return S}function A(t,e={},r=null){let s={alpha:5,beta:5,dt:.01,muFriction:0,collisionThreshold:.01};for(let t in s)e.hasOwnProperty(t)||(console.log(`PARAMETERS object does not have key ${t}, using default value ${s[t]}`),e[t]=s[t]);return _(state,e,r)}function x(t,e){let r=document.createElementNS("http://www.w3.org/2000/svg",e);return t.appendChild(r),r}function w(t,e,r,s,i,n="black"){t.select(`#${i}`).remove();var o=t.append("g").attr("id",i);o.append("line").attr("x1",e-s/2).attr("y1",r-s/2).attr("x2",e+s/2).attr("y2",r+s/2).attr("stroke",n),o.append("line").attr("x1",e-s/2).attr("y1",r+s/2).attr("x2",e+s/2).attr("y2",r-s/2).attr("stroke",n)}function b(t,e,r,s,i,n,o="arrow",a="black"){let l=t.select(`#${n}`);if(l.empty()){(l=t.append("g").attr("id",n)).append("line").attr("id",`${n}_line`);l.append("defs").append("marker").attr("id",`${n}_head`).attr("viewBox","0 -5 10 10").attr("refX",5).attr("refY",0).attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5").attr("class",o).attr("fill",a)}l.select(`#${n}_line`).attr("x1",e).attr("y1",r).attr("x2",s).attr("y2",i).attr("stroke-width",2).attr("stroke",a).attr("class",o).attr("marker-end",`url(#${n}_head)`),l.select(`#${n}_head path`).attr("fill",a)}function v(t,e,r="constraints"){let s=0===t.constraints_distance.length,i=0===t.constraints_pin.length,n=t.xs;if(!s){let s=t.constraints_distance,i=s.map(t=>t[2]),o=s.map(t=>[t[0],t[1]]);!function(t,e,r,s,i,n="black",o=[]){let a=t.querySelector(`#${i}`);null==a&&(a=x(t,"g")).setAttribute("id",i);for(let t=0;t<r.length;t++){let l=r[t],c=e[l[0]][0],h=e[l[0]][1],d=e[l[1]][0],p=e[l[1]][1],u=s[t],g=Math.sqrt((d-c)**2+(p-h)**2),m=c+(d-c)/g*u,f=h+(p-h)/g*u,y=a.querySelector(`#line_${i}_${t}`);if(null==y&&(y=x(a,"line")).setAttribute("id",`line_${i}_${t}`),y.setAttribute("x1",c),y.setAttribute("y1",h),y.setAttribute("x2",m),y.setAttribute("y2",f),y.setAttribute("stroke",n),o.length>0){if(o.length!=r.length)throw new Error("labels_segments must have the same length as constraints_idxs");let e=(c+d)/2,s=(h+p)/2,l=o[t],u=a.querySelector(`#label_${i}_${t}`);null==u&&(u=x(a,"text")).setAttribute("id",`label_${i}_${t}`),u.setAttribute("x",e),u.setAttribute("y",s),u.textContent=l,u.setAttribute("fill",n),u.setAttribute("font-size","18px"),u.setAttribute("text-anchor","middle")}}}(e,n,o,i,r+"_distance","black",Array.from(Array(o.length).keys()).map(t=>`Segd${t}`))}if(!i){let s=t.constraints_pin,i=s.map(t=>t[0]);!function(t,e,r,s,i,n,o="black",a=[]){if(r.length!=s.length)throw new Error("constraints_idxs and pinpoints must have the same length");let l=t.querySelector(`#${n}`);null==l&&(l=x(t,"g")).setAttribute("id",n);for(let t=0;t<r.length;t++){let c=r[t],h=e[c][0],d=e[c][1],p=s[t][0],u=s[t][1],g=i[t],m=Math.sqrt((p-h)**2+(u-d)**2),f=h+(p-h)/m*g,y=d+(u-d)/m*g,_=l.querySelector(`#line_${n}_${t}`);if(null==_&&(_=x(l,"line")).setAttribute("id",`line_${n}_${t}`),_.setAttribute("x1",h),_.setAttribute("y1",d),_.setAttribute("x2",f),_.setAttribute("y2",y),_.setAttribute("stroke",o),a.length>0){if(a.length!=r.length)throw new Error("labels_segments must have the same length as constraints_idxs");let e=(h+p)/2,s=(d+u)/2,i=a[t],c=l.querySelector(`#label_${n}_${t}`);null==c&&(c=x(l,"text")).setAttribute("id",`label_${n}_${t}`),c.setAttribute("x",e),c.setAttribute("y",s),c.textContent=i,c.setAttribute("fill",o),c.setAttribute("font-size","18px"),c.setAttribute("text-anchor","middle")}}for(let e=0;e<r.length;e++){let r=s[e][0],i=s[e][1],a=`pin_cross_${n}_${e}`;w(d3.select(t),r,i,10,a,o="black")}}(e,n,i,s.map(t=>t[1]),s.map(t=>t[2]),r+"_pin","black",Array.from(Array(i.length).keys()).map(t=>`Segp${t}`))}}class E{constructor(t,e,r,s="polygonsGroup",i="blue"){this.polygonObj=new p(e,r),this.polygonsGroupId=s,this.draw(t,i)}draw(t,e="blue",r=20){let s=this.polygonsGroupId+"_polygon_"+this.polygonObj.id,i=document.getElementById(s);null===i&&((i=x(t,"g")).id=s);let n=this.polygonObj.vertices;!function(t,e,r,s="black"){let i=t.querySelector(`#${e}`);if(i){if(i.points.length!=r.length)throw new Error(`Invalid number of points for polygon ${e}`);let t=r.map(t=>t.join(",")).join(" ");i.setAttribute("points",t)}else{let i=x(t,"polygon"),n=r.map(t=>t.join(",")).join(" ");i.setAttribute("points",n),i.setAttribute("fill",s),i.setAttribute("id",e)}}(i,i.id+"_polygon",n,"blue");let o=math.mean(n,0),a=i.id+"_id",l=i.querySelector(`#${a}`);null===l&&((l=x(i,"text")).id=a,l.setAttribute("x",o[0]),l.setAttribute("y",o[1]),l.setAttribute("fill","black"),l.setAttribute("font-size","25px"),l.setAttribute("text-anchor","middle"),l.setAttribute("alignment-baseline","middle"),l.textContent=this.polygonObj.id),this.drawNormals(i,"black",r)}drawNormals(t,e="black",r=1){let s=this.polygonObj.getNormals(),i=this.polygonsGroupId+"_polygon_"+this.polygonObj.id,n=document.getElementById(i);if(null===n)throw new Error("Polygon group must be created before drawing normals");for(let t=0;t<s.length;t++){let o=s[t],a=i+"_normal_"+t,l=this.polygonObj.getEdgeMidpoint(t);document.getElementById(a);b(d3.select(n),l[0],l[1],l[0]-o[0]*r,l[1]-o[1]*r,a,"normal",e);let c=a+"_text",h=n.querySelector(`#${c}`);null===h?((h=x(n,"text")).id=c,h.setAttribute("x",l[0]-o[0]*r),h.setAttribute("y",l[1]-o[1]*r),h.setAttribute("fill","black"),h.setAttribute("font-size","12px"),h.setAttribute("text-anchor","middle"),h.setAttribute("alignment-baseline","middle"),h.textContent=t):(h.setAttribute("x",l[0]-o[0]*r),h.setAttribute("y",l[1]-o[1]*r))}}}class P{constructor(t,e,r){this.svg=t,this.particles_group_id=e,this.polygons_group_id=r}drawCollisions(t,e){for(let e of t)this._enterCollision(e);for(let t of e)this._exitCollision(t)}_enterCollision(t){let[e,r,s]=t,i=this._getParticleByIdx(e),n=this._getNormalByIdxPolygon(s,r);i.attr("fill","red"),n.attr("stroke","red")}_exitCollision(t){let[e,r,s]=t,i=this._getParticleByIdx(e),n=this._getNormalByIdxPolygon(s,r);i.attr("fill","green"),n.attr("stroke","black")}_getParticleByIdx(t){let e=d3.select(`#${this.particles_group_id}_particle_${t}`);if(e.empty()){let e=`#${this.particles_group_id}_particle_`;throw new Error(`Particle with index ${t} not found, query: ${e}`)}return e}_getNormalByIdxPolygon(t,e){let r=d3.select(`#${this.polygons_group_id}_polygon_${t}_normal_${e}`);if(r.empty())throw new Error(`Normal with index ${e} not found in polygon ${t}`);return r}}function $(t,e,r,s,i,n=10){const o=r[0]-e[0],a=r[1]-e[1],l=Math.sqrt(o*o+a*a),c=[o/l,a/l],h=[-c[1],c[0]],d=.1*s;let p=document.getElementById(i);p&&t.removeChild(p);let u=x(t,"g");u.setAttribute("id",i);for(let t=0;t<n;t++){const s=t/n,i=(t+1)/n,l=t%2==0?1:-1,c=0===t?[e[0],e[1]]:[e[0]+s*o+l*h[0]*d,e[1]+s*a+l*h[1]*d],p=t===n-1?[r[0],r[1]]:[e[0]+i*o-l*h[0]*d,e[1]+i*a-l*h[1]*d];let g=x(u,"line");g.setAttribute("x1",c[0]),g.setAttribute("y1",c[1]),g.setAttribute("x2",p[0]),g.setAttribute("y2",p[1]),g.setAttribute("stroke","black"),g.setAttribute("stroke-width","2")}}class C{constructor(t,e=[-1,1],r=[-1,1],s=[0,0]){this.svg=t,this.x_model_domain=e,this.y_model_domain=r,this.origin_model=s}_checkInitState(t){if(!t.hasOwnProperty("xs"))throw new Error("Missing xs in STATE");if(!t.hasOwnProperty("masses"))throw new Error("Missing masses in STATE");let e=t.xs.length,r=["vs","external_forces","constraint_forces","contact_forces","friction_forces","actuator_forces","total_forces"],s=["polygons","constraints_distance","constraints_pin","collisions","new_collisions","resolved_collisions","springs","springs2points"];for(let s of r)t.hasOwnProperty(s)||(t[s]=Array(e).fill().map(()=>Array(2).fill(0)),console.info(`Property ${s} not found in STATE, initializing to zeros`));for(let e of s)t.hasOwnProperty(e)||(t[e]=[],console.info(`Property ${e} not found in STATE, initializing to empty array`));return t}getCanvasDimensions(){let t=this.svg.clientWidth,e=this.svg.clientHeight;if(0===t||0===e)throw new Error("Width or height of the svg is 0");return[t,e,[t/2,e/2],t/(this.x_model_domain[1]-this.x_model_domain[0]),-e/(this.y_model_domain[1]-this.y_model_domain[0])]}model2Canvas(t,e=!1){if(!Array.isArray(t))throw new Error("Array should be an array");if(0===t[0].length)throw new Error("Array must be of shape [N,2]");let[r,s,i,n,o]=this.getCanvasDimensions();return t.map(t=>{let r=t[0],s=t[1],a=[0,0];return e?(a=[this.origin_model[0],this.origin_model[1]],i=[i[0],i[1]]):(a=[0,0],i=[0,0]),[(r+a[0])*n+i[0],(s+a[1])*o+i[1]]})}canvas2Model(t,e=!1){if(!Array.isArray(t))throw new Error("Array should be an array");if(0===t[0].length)throw new Error("Array must be of shape [N,2]");let[r,s,i,n,o]=this.getCanvasDimensions();return t.map(t=>{let r=t[0],s=t[1],a=[0,0];return e?(a=[this.origin_model[0],this.origin_model[1]],i=[i[0],i[1]]):(a=[0,0],i=[0,0]),[(r-i[0])/n+a[0],(s-i[1])/o+a[1]]})}_calculateDistance(t,e){return Math.sqrt((t[0]-e[0])**2+(t[1]-e[1])**2)}_masses2Radiuses(t,e){return t.map(t=>Math.sqrt(t/e/Math.PI))}state2Canvas(t){let e=JSON.parse(JSON.stringify(t));e.xs=this.model2Canvas(t.xs,!0),e.vs=this.model2Canvas(t.vs,!1),e.external_forces=this.model2Canvas(t.external_forces,!1),e.constraint_forces=this.model2Canvas(t.constraint_forces,!1),e.contact_forces=this.model2Canvas(t.contact_forces,!1),e.friction_forces=this.model2Canvas(t.friction_forces,!1),e.total_forces=this.model2Canvas(t.total_forces,!1),e.actuator_forces=this.model2Canvas(t.actuator_forces,!1);let r=e.constraints_distance.map(e=>{let[r,s,i]=e,n=t.xs[r],o=t.xs[s],a=o[0]-n[0],l=o[1]-n[1],c=i/Math.sqrt(a**2+l**2),h=this.model2Canvas([[c*a,c*l]],!1)[0];return[r,s,Math.sqrt(h[0]**2+h[1]**2)]});e.constraints_distance=r;let s=e.constraints_pin.map(e=>{let[r,s,i]=e,n=t.xs[r],o=s[0]-n[0],a=s[1]-n[1],l=i/Math.sqrt(o**2+a**2),c=this.model2Canvas([[l*o,l*a]],!1)[0],h=Math.sqrt(c[0]**2+c[1]**2);return[r,this.model2Canvas([s],!0)[0],h]});e.constraints_pin=s;let i=t.polygons.map(t=>this.model2Canvas(t,!0));if(e.polygons=i,t.hasOwnProperty("springs")){let r=t.springs.map(e=>{let[r,s,i,n]=e,o=t.xs[r],a=t.xs[s],l=a[0]-o[0],c=a[1]-o[1],h=Math.sqrt(l**2+c**2),[d,p]=this.model2Canvas([o,a],!0);return[r,s,i,this._calculateDistance(d,p)/h*n]});e.springs=r}if(t.hasOwnProperty("springs2points")){let r=t.springs2points.map(e=>{let[r,s,i,n]=e,o=t.xs[r],a=s[0]-o[0],l=s[1]-o[1],c=Math.sqrt(a**2+l**2),[h,d]=this.model2Canvas([o,s],!0);return[r,d,i,this._calculateDistance(h,d)/c*n]});e.springs2points=r}return e}drawPolygons(t,e,r,s="blue"){for(let[i,n]of e.entries())new E(t,n,i,r,s)}drawCollisions(t,e,r,s,i){new P(t,s,i).drawCollisions(e,r)}drawSprings(t,e,r,s,i){if(0!==e.length){if(e.length!==r.length||e.length!==s.length)throw new Error("points1, points2 and restLengths must be of the same length");let n=document.getElementById(i);n&&t.removeChild(n),(n=x(t,"g")).id=i;for(let t=0;t<e.length;t++){let o=i+"_spring_"+t;$(n,e[t],r[t],s[t],o)}}}drawState(t,e="particlesGroup",r="polygonsGroup",s={},i="springsGroup",n="constraintsGroup"){let o=this.svg.id,a=o+"_"+e,l=o+"_"+r,c=o+"_"+i,h=o+"_"+n;this.particlesGroupId=a,this.polygonsGroupId=l,this.springsGroupId=c,this.constraintsGroupId=h;let d={particle_density:.005,scale_arrows_forces:1,color_particles:"red",color_polygons:"blue"};for(let t in d)s.hasOwnProperty(t)||(s[t]=d[t]);let p=t=this._checkInitState(t),u=d3.select(this.svg),g=s.particle_density,m=p.masses.map(t=>Math.sqrt(t/g)),f=s.scale_arrows_forces,y=this.state2Canvas(p);!function(t,e,r,s,i="red"){"number"==typeof r&&(r=Array(e.length).fill(r));let n=t.selectAll(`#${s}`).data([null]).join("g").attr("id",s),o=[];for(let t=0;t<e.length;t++)o.push({x:e[t][0],y:e[t][1],r:r[t],idx:t});let a=n.selectAll(".particle").data(o),l=a.enter().append("g").attr("class","particle").attr("id",t=>`${s}_particle_${t.idx}`);l.append("circle"),l.append("text"),(a=l.merge(a)).select("circle").attr("cx",(t,e)=>t.x).attr("cy",(t,e)=>t.y).attr("r",(t,e)=>t.r).attr("fill",i),a.select("text").attr("x",(t,e)=>t.x).attr("y",(t,e)=>t.y).text((t,e)=>`${e}`),a.exit().remove()}(u,y.xs,m,a,s.color_particles),function(t,e,r=1){let s=["external_forces","constraint_forces","contact_forces","friction_forces"].filter(e=>!t.hasOwnProperty(e));if(s.length>0)throw new Error("Missing forces in STATE: "+s);if(!t.hasOwnProperty("xs"))throw new Error("Missing xs in STATE");let i=t.external_forces,n=t.constraint_forces,o=t.contact_forces,a=t.friction_forces,l=t.total_forces,c=t.actuator_forces,h=t.xs,d=r;for(let t=0;t<h.length;t++){let[r,s]=h[t],[p,u]=i[t];b(e,r,s,r+d*p,s+d*u,"arrow_fext_"+t,"arrow force fext","blue"),[p,u]=n[t],b(e,r,s,r+d*p,s+d*u,"arrow_fconstraint_"+t,"arrow force fconstraint","green"),[p,u]=o[t],b(e,r,s,r+d*p,s+d*u,"arrow_fcontact_"+t,"arrow force fcontact","red"),[p,u]=a[t],b(e,r,s,r+d*p,s+d*u,"arrow_ffriction_"+t,"arrow force ffriction","purple"),[p,u]=l[t],b(e,r,s,r+d*p,s+d*u,"arrow_ftotal_"+t,"arrow force ftotal","black"),[p,u]=c[t],b(e,r,s,r+d*p,s+d*u,"arrow_factuators_"+t,"arrow force factuators","orange")}}(y,u,f),v(y,this.svg,h),this.drawPolygons(this.svg,y.polygons,l,s.color_polygons),this.drawCollisions(this.svg,y.new_collisions,y.resolved_collisions,a,l);let _=y.springs.map(t=>y.xs[t[0]]),A=y.springs.map(t=>y.xs[t[1]]),x=y.springs.map(t=>t[3]),w=y.springs2points.map(t=>y.xs[t[0]]),E=y.springs2points.map(t=>t[1]),P=y.springs2points.map(t=>t[3]);_=_.concat(w),A=A.concat(E),x=x.concat(P),this.drawSprings(this.svg,_,A,x,c)}drawScaleReference(){let t=[[0,0],[.1,0],[.1,.1],[0,.1],[0,0]].map(t=>[t[0]+this.x_model_domain[0]+.2,t[1]+this.y_model_domain[1]-.2]),e=this.model2Canvas(t,!0),r=d3.select(this.svg);r.append("path").datum(e).attr("fill","none").attr("stroke","black").attr("stroke-width",1).attr("d",d3.line().x(t=>t[0]).y(t=>t[1]).curve(d3.curveLinearClosed)),r.append("text").attr("x",e[0][0]+20).attr("y",e[0][1]+10).attr("fill","brown").attr("font-size","12px").attr("text-anchor","middle").attr("alignment-baseline","middle").text("0.1 square model units")}remove(){let t=[this.particlesGroupId,this.polygonsGroupId,this.springsGroupId,this.constraintsGroupId+"_distance",this.constraintsGroupId+"_pin"];for(let e of t){let t=document.getElementById(e);t&&this.svg.removeChild(t)}}}}])});