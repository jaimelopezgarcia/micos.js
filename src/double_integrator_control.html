<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Integration Test</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>
</head>


<style>
    /*
    * lets make a grid of 2 columns main_canvas/plots_panel, and plots_panel will have all its child divs in a row with a scrollbar for 
    * overflow
    */

    #controls_panel{
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
        width: 400px;
        height: 800px;
        margin: 0px;
    }

    body{
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
    }


    .main_canvas{
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
        width: 1800px;
        height: 800px;
        margin: 0px;
        overflow-y: auto ;
        overflow-x: auto;
    }

    .svg_container{
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
        width: 800px;
        height: 800px;
        margin: 0px;
    }

    .svg{
        border: 1px solid black;
        width: 800px;
        height: 800px;
        margin: 0px;
    }

    #timeSlider{
        width: 800px;
    }

    



</style>
<body>

    <div id = "controls">

        <div id = "tab_selector">

        </div>

        <div id = "controls_panel">


            </div>

        

    </div>
    <div id = "main_canvas" class = "main_canvas">
        </div>


    <script type="module">
            import {Drawer} from "./drawing.js"; //drawer.drawState(STATE,VISUAL_OPTIONS,particles_group_id); is the function to draw the state of the system
            import {displayObjectInDiv, displayMouseCoords} from "./utils.js";
            import {initState,StateUtils, stepSemiEulerActiveSet, integrateSystem} from "./solver.js";   
            import {SelectionPanel} from "./dashboardUI.js";
            import {ForceActuator,TorqueActuatorPin} from "./forces_actuators.js";
            /*Example usage of SelectionPanel
                const data = {
                    Particle_0: ['X Position', 'Y Position'],
                    Particle_1: ['X Position', 'Y Position']
                };

                const selectionPanel = new SelectionPanel(data);

                //methods
                selectionPanel.gatherSelections(); //returns an array of the selected checkboxes, for instance ['Particle_0->X Position', 'Particle_1->Y Position']
                selectionPanel.clearSelections(); //clears all the selected checkboxes
                selectionPanel.selectAll(); //selects all the checkboxes
                */

                /* integrateSystem, usage
                //default parameters
                {
                    "alpha": 0.1,
                    "beta": 0.1,
                    "dt": 0.01,
                    "muFriction": 0.0,
                    "collisionThreshold": 0.01,
                }
                let actuator = new ForceActuator([0],[0,0.1]);
                let forceActuator = actuator.getForceArray.bind(actuator);
                integrateSystem(STATE,nsteps,
                --callbacksActuators =-- [forceActuator],
                 --method =-- "SemiEulerActiveSet", --PARAMETERS =-- {})
                */

                /*
                Example usage drawer


                let drawer = new Drawer(svgMain, [-2,2],[-2,2]);

            
                let nsteps = stateStoryModel.length;

                drawer.drawState(stateStoryModel[0]);

                                function canvas2ModelCallback(points){
                    return drawer.canvas2Model(points, true)// true for shifing origin, false if transforming forces
                }


                Example usage TorqueActuatorPin

            let torqueFun = (theta, omega, time) => torqueFunction(theta, omega, time, 0.0, 50, 0.5);
        let actuator = new TorqueActuatorPin([0,0], 0, torqueFun); pinpoint targetParticletorqueFunction
            let callbacksActuators = [actuator.getForceArray.bind(actuator)];
                */


        // lets make a pid controller for the double integrator to reach a target position on the y axis

         


 




        function plotResults(stateStory,controller,parentDivId){
            //lets go over some basic diff equations/classical mechanics concepts so things are clear.
            // ok so m\dot\dot{x} = f = u. Multiplying \dot{x} to both sides we get m\dot{x}\dot\dot{x} = u\dot{x}
            //we can use the relationship \dot{x}\dot\dot{x} = \frac{1}{2}\frac{d}{dt}(\dot{x}^2)
            // so we get 1/2*md(x**2)/dt = u\dot{x}dt, the extension to multiple particles and control signals is straightforward
            // now for generalized coordinates q, we'll still have a quadratic relationship but with different mass matrix
            // for torque we get I\dot{\omega} = \tau = u_{tau}, so basically the same but with angular velocity and torque
            // d1/2I\omega^2/dt = u_{tau}\omega dt So, generalized forces go in pairs with generalized velocities/displacements
            // for both cartesian and generalized coordinates, the application is straightforward
            //lets calculate the different magnitudes we'll be plotting


            //state already has totalEnergy variable , lets get cumulative energy and power consumed by the controller

            let totalEnergyArray = stateStory.map((state) => state.totalEnergy);
            let [cumEnergyArray,powerArray] = controller.getControllerTotalEnergyConsumed(stateStory);
            let [timeArray,uArray,yArray,vyArray] = controller.getTimeArrayControlSignalControlledVar(stateStory);

            //lets do two plots one with cumEnergy powerArray totalEnergy vs time 
            //and the other with uArray yArray vyArray vs time

            let traces = [
                {
                    x: timeArray,
                    y: uArray,
                    mode: 'lines',
                    name: 'Control Signal',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: yArray,
                    mode: 'lines',
                    name: 'Controlled Variable Position',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: vyArray,
                    mode: 'lines',
                    name: 'Controlled Variable Velocity',
                    type: 'scatter'
                },
                //lets add twoa additional traces, one dashed horizontal line for the setpoint and a trace with the error in red

                {
                    x: timeArray,
                    y: Array(timeArray.length).fill(controller.getSetpoint()),
                    mode: 'lines',
                    name: 'Setpoint',
                    type: 'scatter',
                    line: {
                        dash: 'dashdot',
                        color: 'black'
                    }
                },
                {
                    x: controller.getErrorTime(stateStory)[0],
                    y: controller.getErrorTime(stateStory)[1],
                    mode: 'lines',
                    name: 'Error',
                    type: 'scatter',
                    line: {
                        color: 'red'
                    }
                }
            ];




            let layout = {
                title: 'Control Signal and Controlled Variable vs Time',
                xaxis: {
                    title: 'Time'
                },
                yaxis: {
                    title: 'Control Signal/Controlled Variable'
                }
            };


            let traces2 = [
                {
                    x: timeArray,
                    y: cumEnergyArray,
                    mode: 'lines',
                    name: 'Controller Cumulative Energy Consumed',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: powerArray,
                    mode: 'lines',
                    name: 'Controller Power',
                    type: 'scatter'
                },
                {
                    x: timeArray,
                    y: totalEnergyArray,
                    mode: 'lines',
                    name: 'System Total Energy',
                    type: 'scatter'
                }
            ];

            let layout2 = {
                title: 'Energy and Power vs Time',
                xaxis: {
                    title: 'Time'
                },
                yaxis: {
                    title: 'Energy/Power'
                }
            };

            let plotDiv1 = document.createElement("div");
            let plotDiv2 = document.createElement("div");
            plotDiv1.setAttribute("id","plotDiv1");
            plotDiv2.setAttribute("id","plotDiv2");
            document.getElementById(parentDivId).appendChild(plotDiv1);
            document.getElementById(parentDivId).appendChild(plotDiv2);



            Plotly.newPlot(plotDiv1, traces, layout);
            Plotly.newPlot(plotDiv2, traces2, layout2);





        }


//drawing function is generic so lets create a general function
function drawStateStory(stateStory,pidController){

         let nsteps = stateStory.length;
    
                
        let mainCanvas = document.getElementById("main_canvas");
                let parentDiv = document.getElementById("svg_container");
                if(parentDiv == null){
                    parentDiv = document.createElement("div");
                    parentDiv.setAttribute("id","svg_container");
                    //lets set a classname to make in the css the slider to be in the bottom of the svg
                    parentDiv.setAttribute("class","svg_container");
                    mainCanvas.appendChild(parentDiv);
                }

                let svgDraw = document.getElementById("svgDraw");
                if(svgDraw == null){
                    svgDraw = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svgDraw.setAttribute("id","svgDraw");
                    svgDraw.setAttribute("class","svg");
                    parentDiv.appendChild(svgDraw);
                }

                let [xModelDomain,yModelDomain] = [[-1,1],[-1,1]];
                let drawer = new Drawer(svgDraw);

                //draw the last state of the stateStory array
                drawer.drawState(stateStoryModel[nsteps-1]);

                //create a slider to select the time snapshot of the stateStory array
                let slider = document.getElementById("timeSlider");

                //lets remove it if it exists
                if(slider != null){
                    slider.remove();
                }

                slider = document.createElement("input");
                slider.setAttribute("type","range");
                slider.setAttribute("min","0");
                slider.setAttribute("max",nsteps-1);
                slider.setAttribute("value",nsteps-1);
                slider.setAttribute("id","timeSlider");
                parentDiv.appendChild(slider);


                //lets create another div to print the state
                let stateDiv = document.createElement("div");
                stateDiv.setAttribute("id","stateDiv");
                //lets append child to the mainCanvas
                let body = document.getElementsByTagName("body")[0];
                body.appendChild(stateDiv);
                

                //add event listener to the slider
                slider.addEventListener("input", function(){
                    let time = parseInt(slider.value);
                    drawer.drawState(stateStoryModel[time]);
                    displayObjectInDiv(stateStoryModel[time],"stateDiv");
                })

                function canvas2ModelCallback(points){
                        return drawer.canvas2Model(points, true)// true for shifing origin, false if transforming forces
                    }

                    displayMouseCoords( svgDraw, canvas2ModelCallback);

                //lets plot the results of the controller
                let plotsDivId = "plotsDiv";
                let plotsDiv = document.getElementById(plotsDivId);
                if(plotsDiv == null){
                    plotsDiv = document.createElement("div");
                    plotsDiv.setAttribute("id",plotsDivId);
                    mainCanvas.appendChild(plotsDiv);
                }
                else{
                    //clear the div
                    plotsDiv.innerHTML = "";
                }

                plotResults(stateStoryModel,pidController,plotsDivId);

                return [drawer,slider,stateDiv,plotsDiv,svgDraw];
            }





























































        ////Double Integrator with PID Controller////

        function tabDIntegrator(){


            class PIDControllerDIntegrator{
                constructor(Kp,Ki,Kd,setPoint,dt){
                    this.Kp = Kp;
                    this.Ki = Ki;
                    this.Kd = Kd;
                    this.integral = 0;
                    this.prev_error = 0;
                    this.setPoint = setPoint;
                    this.dt = dt;
                    this.init = true;
                }

                reset(){
                    this.integral = 0;
                    this.prev_error = 0;
                    this.init = true;
                }

                getName(){
                    return "PIDController";
                }

                getForceArray(STATE){
                    //lets calculate the error and force and we'll use a force actuator to apply the force
                    let error = this.setPoint - STATE.xs[0][1];
                    this.integral += error*this.dt;
                    //let derivative = (error - this.prev_error)/this.dt;
                    let derivative = 0;
                    if (this.init){
                        this.init = false;
                        
                    }else{
                        derivative = (error - this.prev_error)/this.dt;
                    }
                    let force = this.Kp*error + this.Ki*this.integral + this.Kd*derivative;
                    this.prev_error = error;
                    
                    let forceActuator = new ForceActuator([0],[0,force]);
                    return forceActuator.getForceArray(STATE);
    
                }

                getForce(STATE){
                    //lets calculate the error and force and we'll use a force actuator to apply the force
                    let forceArray = this.getForceArray(STATE);
                    let force = forceArray[0];
                    return force;
    
                }

                getControlledVarPositionVelocity(STATE){
                    // in this case we return [y,vy]
                    return [STATE.xs[0][1],STATE.vs[0][1]];
                }

                getTimeArrayControlSignalControlledVar(stateStory){
                    // we return a [nsteps,3] array with u,y,vy and a [nsteps] array with time
                    
                    this.reset();

                    let timeArray = stateStory.map((state) => state.time);

                    let uArray = [];
                    let yArray = [];
                    let vyArray = [];

                    for(let i = 0; i < stateStory.length; i++){
                        let state = stateStory[i];
                        let u = this.getForce(state)[1];
                        let [y,vy] = this.getControlledVarPositionVelocity(state);
                        uArray.push(u);
                        yArray.push(y);
                        vyArray.push(vy);
                    }

                    return [timeArray,uArray,yArray,vyArray];

                }

                
                getControllerInstantaneousPower(STATE){
                    //lets calculate the power consumed by the controller
                    //P_{consumed} = |u*\dot{controlled_variable}| = |f_{ycontroller}*\dot{y}| 
                    let force = this.getForce(STATE);
                    let vy = STATE.vs[0][1];
                    let power = force[1]*vy//lets keep the sign
                    // of the power just for debugging purposes, so we can now when it is adding or removing energy
                    return power;
                }
                getControllerTotalEnergyConsumed(stateStory){
                    /*
                    This function returns two arrays of [nsteps] elements, one with the cumulative energy consumed by the controller
                    and the other with the power consumed by the controller at each step
                    */
                    //lets calculate the total energy consumed by the controller
                    //E_{consumed} = \int_{0}^{t} |u*\dot{controlled_variable}|dt


                    this.reset();

                    let totalEnergy = 0;
                    let arrayCumEnergy = [];
                    let powerArray = [];
                    let power = 0;
                    arrayCumEnergy.push(0);
                    powerArray.push(0);

                    //lets get the dt from the stateStory at each step
                    for (let i = 0; i < stateStory.length-1; i++){
                        let dt = stateStory[i+1].time - stateStory[i].time;
                        let power = this.getControllerInstantaneousPower(stateStory[i]);
                        totalEnergy += math.abs(power)*dt;
                        arrayCumEnergy.push(totalEnergy);
                        powerArray.push(power);
                    }
                    return [arrayCumEnergy,powerArray];
                }

                getSetpoint(){
                    return this.setPoint;
                }

                getErrorTime(stateStory){
                    //returns an array with the error at each time step
                    let errorArray = [];
                    let timeArray = stateStory.map((state) => state.time);
                    for(let i = 0; i < stateStory.length; i++){
                        let error = this.setPoint - stateStory[i].xs[0][1];
                        errorArray.push(error);
                        timeArray.push(stateStory[i].time);

                    }
                    return [timeArray,errorArray];
                }


            }      

            function doubleIntegratorConfig(x0, v0, mass, dampingCoef = 0.){
                let initialState = {
                    xs: [x0],
                    vs: [v0],
                    masses: [mass],
                    constraints_distance: [],
                    constraints_pin: [],
                    collisions: [],
                    gravity: [0,[0,-1]],
                    time: 0,
                    polygons: [],
                    damping: [ [[0],dampingCoef] ],
                }

                return initialState;
            }

            function mainDIntegrator(Kp,Ki,Kd,setPoint,dt,T,y0in = 0,vy0in = 0){
                console.log("Kp,Ki,Kd,setPoint,dt,T,y0in,vy0in",Kp,Ki,Kd,setPoint,dt,T,y0in,vy0in);
                // if any of the parameters is not passed, throw error
                if (Kp == undefined || Ki == undefined || Kd == undefined || setPoint == undefined || dt == undefined || T == undefined){
                    throw new Error("Missing parameters");
                }

                //lets test the double integrator with a force actuator
                //we integrate the system with a actuator callaback 
                //then we draw the state of the system and create a slider to select the time snapshot of the stateStory array that
                //integrateSystem returns

                //state config parameters
                let [x0,v0,mass,dampingCoef] = [[0,y0in],[0,vy0in],1,0];
                let initialState = doubleIntegratorConfig(x0,v0,mass,dampingCoef);

                //actuator config parameters, constant force of 0.1 in the y direction
            //  let actuator = new ForceActuator([0],[0,0.1]);
                //let forceActuator = actuator.getForceArray.bind(actuator);

                //lets create a PID controller to reach a target position on the y axis

                let nsteps = Math.floor(T/dt);

                let pidController = new PIDControllerDIntegrator(Kp,Ki,Kd,setPoint,dt);
                let forceActuator = pidController.getForceArray.bind(pidController);
                window.pidController = pidController;
                //default parameters
                
                let stateStoryModel = integrateSystem(initialState,nsteps,[forceActuator],"SemiEulerActiveSet",{"dt":dt});
                window.stateStoryModel = stateStoryModel;
                window.initState = stateStoryModel[0];
                //lets create a svg if it not exists to draw the state of the system
                //lets use vanilla svg and js, no d3 or plotly for this one


                let [drawer,slider,stateDiv,plotsDiv,svgDraw] = drawStateStory(stateStoryModel,pidController);
                //lets draw an horizontal line with the setpoint on the main svg

                let ySetpoint = pidController.getSetpoint();
                let setPointHlineModel = [[-1,ySetpoint],[1,ySetpoint]];
                //lets remove the previous setPointHline if it exists
                let setPointHline = document.getElementById("setPointHline");
                if(setPointHline != null){
                    setPointHline.remove();
                }
                let setPointHlineCanvas = drawer.model2Canvas(setPointHlineModel,true);
                let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1",setPointHlineCanvas[0][0]);
                line.setAttribute("y1",setPointHlineCanvas[0][1]);
                line.setAttribute("x2",setPointHlineCanvas[1][0]);
                line.setAttribute("y2",setPointHlineCanvas[1][1]);
                line.setAttribute("stroke","black");
                line.setAttribute("stroke-width","2");
                line.setAttribute("stroke-dasharray","5,5");
                line.setAttribute("id","setPointHline");
                svgDraw.appendChild(line);



            }

        
        function addControlsDIntegrator(){
            let controlsPanel = document.getElementById("controls_panel");
            let controls = [
                {
                    "label": "Kp",
                    "id": "Kp",
                    "type": "range",
                    "value": 0.5,
                    "step": 0.05,
                    "min": 0,
                    "max": 20
                },
                {
                    "label": "Ki",
                    "id": "Ki",
                    "type": "range",
                    "value": 0,
                    "step": 0.05,
                    "min": 0,
                    "max": 20
                },
                {
                    "label": "Kd",
                    "id": "Kd",
                    "type": "range",
                    "value": 0.5,
                    "step": 0.05,
                    "min": 0,
                    "max": 20
                },
                {
                    "label": "setPoint",
                    "id": "setPoint",
                    "type": "range",
                    "value": 0.5,
                    "step": 0.05,
                    "min": -10,
                    "max": 10
                },
                {
                    "label": "dt",
                    "id": "dt",
                    "type": "range",
                    "value": 0.1,
                    "step": 0.01,
                    "min": 0.01,
                    "max": 1
                },
                {
                    "label": "T",
                    "id": "T",
                    "type": "range",
                    "value": 20,
                    "step": 1,
                    "min": 1,
                    "max": 100
                },
                {
                    "label": "y0in",
                    "id": "y0in",
                    "type": "range",
                    "value": 0,
                    "step": 0.1,
                    "min": -10,
                    "max": 10
                },
                {
                    "label": "vy0in",
                    "id": "vy0in",
                    "type": "range",
                    "value": 0,
                    "step": 0.1,
                    "min": -10,
                    "max": 10
                }
            ];



            for (let i = 0; i < controls.length; i++){
                let control = controls[i];
                let label = document.createElement("label");
                label.setAttribute("for",control.id);
                label.innerHTML = `${control.label}: ${control.value}`;
                let input = document.createElement("input");
                input.setAttribute("type",control.type);
                input.setAttribute("id",control.id);
                input.setAttribute("value",control.value);
                input.setAttribute("step",control.step);
                input.setAttribute("min",control.min);
                input.setAttribute("max",control.max);
                controlsPanel.appendChild(label);
                controlsPanel.appendChild(input);
            }


            return controls;

        }
            

        

        function updateCallbackDIntegrator(){
            let Kp = parseFloat(document.getElementById("Kp").value);
            let Ki = parseFloat(document.getElementById("Ki").value);
            let Kd = parseFloat(document.getElementById("Kd").value);
            let setPoint = parseFloat(document.getElementById("setPoint").value);
            let dt = parseFloat(document.getElementById("dt").value);
            let T = parseFloat(document.getElementById("T").value);
            let y0in = parseFloat(document.getElementById("y0in").value);
            let vy0in = parseFloat(document.getElementById("vy0in").value);
            //lets update the label of the controls
            let controls = ["Kp","Ki","Kd","setPoint","dt","T","y0in","vy0in"];
            controls.forEach((control) => {
                document.querySelector(`label[for=${control}]`).innerHTML = `${control}: ${document.getElementById(control).value}`;
            });


            

            mainDIntegrator(Kp,Ki,Kd,setPoint,dt,T,y0in,vy0in);
        }

        let controls = addControlsDIntegrator();
        //any change on the controls will trigger the updateCallback


        controls.forEach((control) => {
            document.getElementById(control.id).addEventListener("change",updateCallbackDIntegrator);
        });

        //initial call to main
        updateCallbackDIntegrator();

    }

    //tabDIntegrator();


































































    ///Simple Pendulum with PID Controller///

    function tabSimplePendulum(){

        function pendulumSystemConfig(thetaO, omegaO, g, L, mass){

            let x0 = [[L*Math.sin(thetaO), -L*Math.cos(thetaO)]]; // [nparticles,2] [1,2] ( 1 particle)
            let v0 = [[omegaO*L*Math.cos(thetaO), omegaO*L*Math.sin(thetaO)]];
            let masses = [mass];
            let constraints_distance = [];
            let constraints_pin = [[0, [0,0], L]];
            let gravity = [g, [0,-1]];
            let time = 0;
            let dampingCoef = 0.;
            let initialState = {
                xs: x0,
                vs: v0,
                masses: masses,
                constraints_distance: constraints_distance,
                constraints_pin: constraints_pin,
                collisions: [],
                gravity: gravity,
                time: time,
                polygons: [],
                damping: x0.map((x,i) => [[i],dampingCoef]),

                }



            return initialState;
            }


            class PIDControllerPendulum{
                constructor(Kp,Ki,Kd,setPointThetaDeg,dt){
                    this.Kp = Kp;
                    this.Ki = Ki;
                    this.Kd = Kd;
                    this.integral = 0;
                    this.prev_error = 0;
                    //lets transform setPointThetaDeg to radians and offset it by -pi/2
                    this.setPointAngleHorizontal = (setPointThetaDeg - 90)*math.pi/180;
                    this.dt = dt;
                    this.init = true;
                    this.stateUtils = new StateUtils();
                }

                reset(){
                    this.integral = 0;
                    this.prev_error = 0;
                    this.init = true;
                }

                getName(){
                    return "PIDControllerPendulum";
                }



                getForceArray(STATE, returnTorque = false){
                    //lets calculate the error and force and we'll use a force actuator to apply the force
                    let effectorAngleHorizontal = this.stateUtils.getAngleSegmentsHorizontal(STATE,"rad")[0];
                    let error = this.setPointAngleHorizontal - effectorAngleHorizontal;


                    this.integral += error*this.dt;
                    //let derivative = (error - this.prev_error)/this.dt;
                    let derivative = 0;
                    if (this.init){
                        this.init = false;
                        
                    }else{
                        derivative = (error - this.prev_error)/this.dt;
                    }
                    let torque = this.Kp*error + this.Ki*this.integral + this.Kd*derivative;
                    this.prev_error = error;

                    let torqueFun = (theta, omega, time) => torque;

                    let pinPoint = STATE.constraints_pin[0][1];
                    
                    let torqueActuator = new TorqueActuatorPin(pinPoint, 0, torqueFun);
                    return torqueActuator.getForceArray(STATE,returnTorque);
    
                }

                getForce(STATE){
                    //lets calculate the error and force and we'll use a force actuator to apply the force
                    let forceArray = this.getForceArray(STATE);
                    let force = forceArray[0];
                    return force;
    
                }

                getTorque(STATE){
                    //lets calculate the error and force and we'll use a force actuator to apply the force
                    let [_,torque] = this.getForceArray(STATE,true);
                    return torque;
                }

                getControlledAngleThetaOmega(STATE,unit = "deg"){
                    
                    let angle = this.stateUtils.getAngleSegmentsHorizontal(STATE,unit)[0]+90;
                    let omega = this.stateUtils.getDotAngleSegments(STATE,unit)[0];

                    return [angle,omega];

                }

                getTimeArrayControlSignalControlledVar(stateStory){

                    this.reset();

                    let timeArray = stateStory.map((state) => state.time);

                    let uArray = [];
                    let yArray = [];
                    let vyArray = [];

                    for(let i = 0; i < stateStory.length; i++){
                        let state = stateStory[i];
                        let u = this.getTorque(state);
                        let [y,vy] = this.getControlledAngleThetaOmega(state);
                        uArray.push(u);
                        yArray.push(y);
                        vyArray.push(vy);
                    }

                    return [timeArray,uArray,yArray,vyArray];
                  
               

                }

                
                getControllerInstantaneousPower(STATE){
                    //lets calculate the power consumed by the controller
                    //P_{consumed} = |u*\dot{controlled_variable}| = |torque*\dot{theta}|
                    
                    let torque = this.getTorque(STATE);
                    let omega = this.stateUtils.getDotAngleSegments(STATE,"rad")[0];
                    let power = torque*omega//lets keep the sign
                    // of the power just for debugging purposes, so we can now when it is adding or removing energy
                    return power;
                }
                getControllerTotalEnergyConsumed(stateStory){
                    /*
                    This function returns two arrays of [nsteps] elements, one with the cumulative energy consumed by the controller
                    and the other with the power consumed by the controller at each step
                    */
                    //lets calculate the total energy consumed by the controller
                    //E_{consumed} = \int_{0}^{t} |u*\dot{controlled_variable}|dt

                    //we have to reset again the controller to avoid using the stored values of derivative and integral terms   
                    this.reset();

                    let totalEnergy = 0;
                    let arrayCumEnergy = [];
                    let powerArray = [];
                    let power = 0;
                    arrayCumEnergy.push(0);
                    powerArray.push(0);

                    //lets get the dt from the stateStory at each step
                    for (let i = 0; i < stateStory.length-1; i++){
                        let dt = stateStory[i+1].time - stateStory[i].time;
                        let power = this.getControllerInstantaneousPower(stateStory[i]);
                        totalEnergy += math.abs(power)*dt;
                        arrayCumEnergy.push(totalEnergy);
                        powerArray.push(power);
                    }
                    return [arrayCumEnergy,powerArray];
                }

                getSetpoint(){
                    let setPointAngleHorizontalDeg = this.setPointAngleHorizontal*180/math.pi;
                    return setPointAngleHorizontalDeg+90;
                }

                getErrorTime(stateStory){
                    
                    let errorArray = [];
                    let timeArray = stateStory.map((state) => state.time);
                    for(let i = 0; i < stateStory.length; i++){
                        let error = this.setPointAngleHorizontal - this.stateUtils.getAngleSegmentsHorizontal(stateStory[i],"rad")[0];

                        //lets transform it to degrees
                        error = error*180/math.pi;
                        errorArray.push(error);
                        timeArray.push(stateStory[i].time);

                    }
                    return [timeArray,errorArray];
                }


            }      


            function mainPendulum(Kp,Ki,Kd,setPointThetaDeg,dt,T,thetaO = 0,omegaO = 0, g = 1, L = 0.5, mass = 1){

                console.log("Kp,Ki,Kd,setPointThetaDeg,dt,T,thetaO,omegaO,g,L,mass",Kp,Ki,Kd,setPointThetaDeg,dt,T,thetaO,omegaO,g,L,mass);
                // if any of the parameters is not passed, throw error
                if (Kp == undefined || Ki == undefined || Kd == undefined || setPointThetaDeg == undefined || dt == undefined || T == undefined){
                    throw new Error("Missing parameters");
                }

                //we integrate the system with a actuator callaback 
                //then we draw the state of the system and create a slider to select the time snapshot of the stateStory array that
                //integrateSystem returns

                //state config parameters
                let initialState = pendulumSystemConfig(thetaO, omegaO, g, L, mass);

                                //lets create a PID controller to reach a target position on the y axis

                let nsteps = Math.floor(T/dt);

                let pidController = new PIDControllerPendulum(Kp,Ki,Kd,setPointThetaDeg,dt);
                let forceActuator = pidController.getForceArray.bind(pidController);
                window.pidController = pidController;
                //default parameters

                let stateStoryModel = integrateSystem(initialState,nsteps,[forceActuator],"SemiEulerActiveSet",{"dt":dt});
                window.stateStoryModel = stateStoryModel;
                window.initState = stateStoryModel[0];
                //lets create a svg if it not exists to draw the state of the system
                //lets use vanilla svg and js, no d3 or plotly for this one


                let [drawer,slider,stateDiv,plotsDiv,svgDraw] = drawStateStory(stateStoryModel,pidController);


                //lets draw a dashed line originated at the pin point and with the angle of the setpoint
                let setPointAngleHorizontal = (setPointThetaDeg - 90)*math.pi/180;
                let pinPoint = initialState.constraints_pin[0][1];
                let setPointAngleLine = [pinPoint,[pinPoint[0]+L*math.cos(setPointAngleHorizontal),pinPoint[1]+L*math.sin(setPointAngleHorizontal)]];

                //lets remove the previous setPointAngle if it exists
                let setPointAngle = document.getElementById("setPointAngle");
                if(setPointAngle != null){
                    setPointAngle.remove();
                }
                
                //lets draw the setPointAngleLine
                //angles are the same in canvas and model no need to transform

                let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                let setPointAngleCanvas = drawer.model2Canvas(setPointAngleLine,true);
                line.setAttribute("x1",setPointAngleCanvas[0][0]);
                line.setAttribute("y1",setPointAngleCanvas[0][1]);
                line.setAttribute("x2",setPointAngleCanvas[1][0]);
                line.setAttribute("y2",setPointAngleCanvas[1][1]);
                line.setAttribute("stroke","black");
                line.setAttribute("stroke-width","2");
                line.setAttribute("stroke-dasharray","5,5");
                line.setAttribute("id","setPointAngle");
                svgDraw.appendChild(line);



            }   

            function addControlsPendulum(){
            let controlsPanel = document.getElementById("controls_panel");
            let controls = [
                {
                    "label": "Kp",
                    "id": "Kp",
                    "type": "range",
                    "value": 0.5,
                    "step": 0.05,
                    "min": 0,
                    "max": 20
                },
                {
                    "label": "Ki",
                    "id": "Ki",
                    "type": "range",
                    "value": 0,
                    "step": 0.05,
                    "min": 0,
                    "max": 20
                },
                {
                    "label": "Kd",
                    "id": "Kd",
                    "type": "range",
                    "value": 0.5,
                    "step": 0.05,
                    "min": 0,
                    "max": 20
                },
                {
                    "label": "setPoint",
                    "id": "setPoint",
                    "type": "range",
                    "value": 30,
                    "step": 0.05,
                    "min": -90,
                    "max": 90
                },
                {
                    "label": "dt",
                    "id": "dt",
                    "type": "range",
                    "value": 0.1,
                    "step": 0.01,
                    "min": 0.01,
                    "max": 1
                },
                {
                    "label": "T",
                    "id": "T",
                    "type": "range",
                    "value": 20,
                    "step": 1,
                    "min": 1,
                    "max": 100
                },
                
                {
                    "label": "thetaO",
                    "id": "thetaO",
                    "type": "range",
                    "value": 0,
                    "step": 1,
                    "min": -180,
                    "max": 180
                },
                {
                    "label": "omegaO",
                    "id": "omegaO",
                    "type": "range",
                    "value": 0,
                    "step": 0.1,
                    "min": -10,
                    "max": 10
                },
                {
                    "label": "g",
                    "id": "g",
                    "type": "range",
                    "value": 1,
                    "step": 0.1,
                    "min": 0,
                    "max": 20
                },
                {
                    "label": "L",
                    "id": "L",
                    "type": "range",
                    "value": 0.5,
                    "step": 0.1,
                    "min": 0.1,
                    "max": 10
                },
                {
                    "label": "mass",
                    "id": "mass",
                    "type": "range",
                    "value": 1,
                    "step": 0.1,
                    "min": 0.1,
                    "max": 10
                }
            ];



            for (let i = 0; i < controls.length; i++){
                let control = controls[i];
                let label = document.createElement("label");
                label.setAttribute("for",control.id);
                label.innerHTML = `${control.label}: ${control.value}`;
                let input = document.createElement("input");
                input.setAttribute("type",control.type);
                input.setAttribute("id",control.id);
                input.setAttribute("value",control.value);
                input.setAttribute("step",control.step);
                input.setAttribute("min",control.min);
                input.setAttribute("max",control.max);
                controlsPanel.appendChild(label);
                controlsPanel.appendChild(input);
            }


            return controls;




        }



        function updateCallbackPendulum(){
            let Kp = parseFloat(document.getElementById("Kp").value);
            let Ki = parseFloat(document.getElementById("Ki").value);
            let Kd = parseFloat(document.getElementById("Kd").value);
            let setPoint = parseFloat(document.getElementById("setPoint").value);
            let dt = parseFloat(document.getElementById("dt").value);
            let T = parseFloat(document.getElementById("T").value);
            let thetaO = parseFloat(document.getElementById("thetaO").value);
            let omegaO = parseFloat(document.getElementById("omegaO").value);
            let g = parseFloat(document.getElementById("g").value);
            let L = parseFloat(document.getElementById("L").value);
            let mass = parseFloat(document.getElementById("mass").value);
            //lets update the label of the controls
            let controls = ["Kp","Ki","Kd","setPoint","dt","T","thetaO","omegaO","g","L","mass"];
            controls.forEach((control) => {
                document.querySelector(`label[for=${control}]`).innerHTML = `${control}: ${document.getElementById(control).value}`;
            });

            mainPendulum(Kp,Ki,Kd,setPoint,dt,T,thetaO,omegaO,g,L,mass);
            





        }


        let controls = addControlsPendulum();
        //any change on the controls will trigger the updateCallback


        controls.forEach((control) => {
            document.getElementById(control.id).addEventListener("change",updateCallbackPendulum);
        });

        //initial call to main
        updateCallbackPendulum();




    }



    let tabSelector = document.getElementById("tab_selector");

    let tabs = [
        {
            "label": "Double Integrator",
            "id": "tabDIntegrator",
            "callback": tabDIntegrator
        },
        {
            "label": "Simple Pendulum",
            "id": "tabSimplePendulum",
            "callback": tabSimplePendulum
        }
    ];

    for (let i = 0; i < tabs.length; i++){
        let tab = tabs[i];
        let button = document.createElement("button");
        button.innerHTML = tab.label;
        button.setAttribute("id",tab.id);
        button.addEventListener("click",(event) => {
            //lets remove the previous tab content
            let mainCanvas = document.getElementById("main_canvas");
            mainCanvas.innerHTML = "";
            //control panel as well
            let controlsPanel = document.getElementById("controls_panel");
            controlsPanel.innerHTML = "";
            //and the plots div
            let plotsDiv = document.getElementById("plotsDiv");
            if(plotsDiv != null){
                plotsDiv.remove();
            }

            //lets remove aswell the staste debug info div
            let stateDiv = document.getElementById("stateDiv");
            if(stateDiv != null){
                stateDiv.remove();
            }


            let tabId = event.target.id;
            let tabCallback = tabs.find((tab) => tab.id == tabId).callback;
            tabCallback();
        });
        tabSelector.appendChild(button);
    }





    //initial tab DIntegrator
    tabDIntegrator();

    </script>
</body>
</html>